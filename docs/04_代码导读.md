# 04 代码导读 - Rust 与 Bevy 初学者指南

## Rust 基础概念

### 1. 所有权系统
```rust
// Rust 的核心：每个值都有一个所有者
let config = GoBoardConfig::default();  // config 拥有这个配置对象

// 借用：& 表示借用，&mut 表示可变借用
fn draw_board(config: &GoBoardConfig) { /* 只读借用 */ }
fn update_config(config: &mut GoBoardConfig) { /* 可变借用 */ }
```

### 2. 结构体和枚举
```rust
// 结构体：组织相关数据
pub struct GoBoardConfig {
    pub board_size: BoardSize,
    pub show_coordinates: bool,
}

// 枚举：表示有限的选项
pub enum BoardSize {
    Nine = 9,
    Thirteen = 13,
    Nineteen = 19,
}
```

### 3. 特征（Trait）
```rust
// Default trait：提供默认值
impl Default for GoBoardConfig {
    fn default() -> Self {
        Self {
            board_size: BoardSize::Nineteen,
            show_coordinates: true,
            // ...
        }
    }
}
```

### 4. 宏（Macro）
```rust
#[derive(Component)]  // 自动生成 Component trait 的实现
struct GoBoard;

#[derive(Debug, Clone)]  // 自动生成调试和克隆功能
struct MyStruct;
```

## Bevy 核心概念详解

### 1. App 构建器
```rust
fn main() {
    App::new()
        .add_plugins(DefaultPlugins)  // 添加 Bevy 默认插件
        .add_plugins(GoBoardPlugin)    // 添加我们的围棋插件
        .add_systems(Startup, setup)   // 启动时执行的系统
        .add_systems(Update, update)   // 每帧执行的系统
        .run();                        // 运行应用
}
```

### 2. 组件（Component）
```rust
// 组件是纯数据，没有行为
#[derive(Component)]
struct GoBoard;  // 标记组件，表示这是一个棋盘

#[derive(Component)]
struct Position {
    x: f32,
    y: f32,
}  // 数据组件，存储位置信息
```

### 3. 系统（System）
```rust
// 系统是处理组件的函数
fn move_system(
    mut query: Query<&mut Transform, With<GoBoard>>  // 查询参数
) {
    for mut transform in query.iter_mut() {
        transform.translation.x += 1.0;  // 移动棋盘
    }
}
```

### 4. 资源（Resource）
```rust
// 资源是全局共享的数据
#[derive(Resource)]
struct CurrentGoBoardConfig(pub GoBoardConfig);

// 在系统中使用资源
fn use_resource(config: Res<CurrentGoBoardConfig>) {
    println!("Board size: {:?}", config.0.board_size);
}
```

### 5. 事件（Event）
```rust
// 定义事件
#[derive(Event)]
struct RedrawBoardEvent;

// 发送事件
fn send_event(mut events: EventWriter<RedrawBoardEvent>) {
    events.send(RedrawBoardEvent);
}

// 接收事件
fn receive_event(mut events: EventReader<RedrawBoardEvent>) {
    for event in events.read() {
        // 处理事件
    }
}
```

## 代码结构解析

### main.rs 解析
```rust
mod go_board;  // 引入模块

use bevy::prelude::*;  // 引入 Bevy 常用类型
use go_board::{GoBoardPlugin, GoBoardConfig, BoardSize};  // 引入我们的类型

fn main() {
    App::new()
        // 配置窗口
        .add_plugins(DefaultPlugins.set(WindowPlugin {
            primary_window: Some(Window {
                title: "围棋".to_string(),
                resolution: (1200.0, 1200.0).into(),  // 窗口大小
                ..default()  // 其他使用默认值
            }),
            ..default()
        }))
        // 添加围棋插件
        .add_plugins(GoBoardPlugin::default())
        // 添加系统
        .add_systems(Startup, setup_camera)
        .add_systems(Update, handle_input)
        .run();
}
```

### go_board.rs 核心逻辑

#### 插件实现
```rust
pub struct GoBoardPlugin {
    pub initial_config: GoBoardConfig,
}

impl Plugin for GoBoardPlugin {
    fn build(&self, app: &mut App) {
        app
            // 添加资源
            .insert_resource(CurrentGoBoardConfig(self.initial_config.clone()))
            // 注册事件
            .add_event::<RedrawBoardEvent>()
            // 添加系统，chain() 确保按顺序执行
            .add_systems(Update, (
                handle_config_update,
                handle_board_redraw,
            ).chain());
    }
}
```

#### 绘制系统
```rust
pub fn draw_board(
    commands: &mut Commands,  // 用于创建实体
    meshes: &mut ResMut<Assets<Mesh>>,  // 网格资源
    materials: &mut ResMut<Assets<ColorMaterial>>,  // 材质资源
    window: &Window,  // 窗口信息
    config: &GoBoardConfig,  // 配置
) {
    // 计算尺寸
    let window_size = window.resolution.width().min(window.resolution.height());
    let cell_size = calculate_cell_size(window_size, config.board_size);
    
    // 创建棋盘背景
    commands.spawn((
        Mesh2d(meshes.add(Rectangle::new(size, size))),  // 2D 网格
        MeshMaterial2d(materials.add(config.board_color)),  // 材质
        Transform::from_translation(Vec3::new(0.0, 0.0, 0.0)),  // 位置
        GoBoard,  // 组件标记
    ));
}
```

## 常见模式解析

### 1. 查询模式
```rust
// 基础查询
Query<&Transform>  // 查询所有有 Transform 的实体

// 带过滤器的查询
Query<&Transform, With<GoBoard>>  // 只查询有 GoBoard 组件的实体

// 多组件查询
Query<(&Transform, &GoBoard)>  // 同时获取两个组件

// 可变查询
Query<&mut Transform>  // 获取可变引用
```

### 2. 事件处理模式
```rust
fn event_handler(
    mut reader: EventReader<MyEvent>,  // 读取事件
    mut writer: EventWriter<OtherEvent>,  // 发送事件
) {
    for event in reader.read() {
        // 处理事件
        writer.send(OtherEvent);
    }
}
```

### 3. 条件执行模式
```rust
// 使用 is_changed() 检测变化
if config.is_changed() {
    // 只在配置改变时执行
}

// 使用 Option 处理可能不存在的情况
if let Ok(window) = windows.get_single() {
    // 安全地处理窗口
}
```

## 调试技巧

### 1. 日志输出
```rust
// 使用 info! 宏输出信息
info!("Board size: {}x{}", width, height);

// 使用 warn! 输出警告
warn!("Invalid board size");

// 使用 error! 输出错误
error!("Failed to create board");
```

### 2. 使用 Debug trait
```rust
#[derive(Debug)]
struct MyStruct { value: i32 }

let s = MyStruct { value: 42 };
println!("{:?}", s);  // 输出: MyStruct { value: 42 }
```

### 3. 使用 Bevy Inspector
```rust
// 可以添加 bevy-inspector-egui 插件来可视化调试
// 在 Cargo.toml 中添加依赖后使用
```

## 性能优化提示

### 1. 避免每帧重绘
```rust
// 坏例子：每帧都重绘
fn update(mut commands: Commands) {
    draw_board(&mut commands);  // 不要这样做！
}

// 好例子：只在需要时重绘
fn update(
    mut events: EventReader<RedrawEvent>,
    mut commands: Commands,
) {
    if !events.is_empty() {
        draw_board(&mut commands);
    }
}
```

### 2. 批量处理
```rust
// 清空所有事件，避免重复处理
events.clear();

// 一次性处理所有变化
for event in events.read() {
    // 收集所有变化
}
// 统一应用变化
```

### 3. 使用 chain() 控制执行顺序
```rust
app.add_systems(Update, (
    system_a,
    system_b,  // system_b 在 system_a 之后执行
).chain());
```

## 扩展建议

### 添加新功能的步骤
1. **定义数据结构**（Component/Resource）
2. **创建事件**（如果需要）
3. **实现系统**（处理逻辑）
4. **注册到 App**（在插件或主函数中）

### 示例：添加计时器
```rust
// 1. 定义资源
#[derive(Resource)]
struct GameTimer {
    elapsed: f32,
}

// 2. 创建系统
fn update_timer(
    time: Res<Time>,
    mut timer: ResMut<GameTimer>,
) {
    timer.elapsed += time.delta_secs();
}

// 3. 注册
app.insert_resource(GameTimer { elapsed: 0.0 })
   .add_systems(Update, update_timer);
```

## 学习路径

### 初学者路线
1. **理解 ECS**：先理解实体、组件、系统的概念
2. **学习查询**：掌握 Query 的使用
3. **处理事件**：理解事件系统
4. **创建插件**：学习模块化组织代码
5. **优化性能**：理解 Bevy 的并行系统

### 进阶路线
1. **自定义渲染**：深入理解 Bevy 的渲染管线
2. **状态管理**：使用 State 管理游戏状态
3. **动画系统**：实现平滑的动画效果
4. **网络功能**：添加多人对战
5. **插件开发**：开发可复用的 Bevy 插件

通过阅读和修改本项目代码，你将逐步掌握 Rust 和 Bevy 的核心概念！