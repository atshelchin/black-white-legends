# 独立开发回旋镖游戏完整指南

> 从零到一，一个人如何用 Bevy 打造类 Boomerang Fu 游戏

## 目录

1. [项目概述与可行性分析](#1-项目概述与可行性分析)
2. [产品设计与核心玩法](#2-产品设计与核心玩法)
3. [技术架构设计](#3-技术架构设计)
4. [项目管理与时间规划](#4-项目管理与时间规划)
5. [美术风格与资源制作](#5-美术风格与资源制作)
6. [音效与音乐设计](#6-音效与音乐设计)
7. [核心系统实现](#7-核心系统实现)
8. [物理与碰撞系统](#8-物理与碰撞系统)
9. [AI系统设计](#9-ai系统设计)
10. [多人游戏架构](#10-多人游戏架构)
11. [关卡设计系统](#11-关卡设计系统)
12. [UI与菜单系统](#12-ui与菜单系统)
13. [优化与打磨](#13-优化与打磨)
14. [测试与迭代](#14-测试与迭代)
15. [发布与运营](#15-发布与运营)

---

## 1. 项目概述与可行性分析

### 1.1 游戏核心概念

**回旋镖大战**是一个快节奏的本地多人对战游戏，玩家控制可爱的角色，使用回旋镖作为主要武器进行战斗。游戏的核心乐趣在于：

- **简单易上手**：只需要移动和投掷两个操作
- **深度策略**：回旋镖的物理特性带来丰富的战术可能
- **即时反馈**：快速的回合，立即的胜负结果
- **社交属性**：本地多人带来的欢乐互动

### 1.2 参考游戏分析

以 **Boomerang Fu** 为主要参考：

| 特性 | Boomerang Fu | 我们的版本 | 实现难度 |
|-----|--------------|-----------|---------|
| 基础移动 | 8方向移动 | 同样实现 | ⭐ |
| 回旋镖投掷 | 自动返回 | 核心机制 | ⭐⭐⭐ |
| 近战攻击 | 快速斩击 | 简化版本 | ⭐⭐ |
| 道具系统 | 10+种道具 | 5种核心道具 | ⭐⭐⭐ |
| 环境互动 | 可破坏墙体 | 基础版本 | ⭐⭐ |
| AI对手 | 3种难度 | 2种难度 | ⭐⭐⭐⭐ |
| 地图数量 | 12张 | 6张 | ⭐⭐ |
| 角色数量 | 12个 | 4个 | ⭐ |

### 1.3 技术可行性评估

**为什么选择 Bevy：**
- ✅ ECS架构非常适合游戏对象管理
- ✅ 内置的2D渲染满足需求
- ✅ 性能优秀，60FPS轻松达成
- ✅ Rust的安全性减少bug
- ⚠️ 物理引擎需要额外集成
- ⚠️ 网络多人较复杂

### 1.4 个人能力评估表

请诚实评估自己的能力（1-5分）：

| 技能领域 | 要求 | 自评 | 提升方案 |
|---------|------|------|---------|
| Rust编程 | 中级 | ___ | 通过项目实践提升 |
| Bevy框架 | 初级 | ___ | 跟随本指南学习 |
| 游戏设计 | 基础 | ___ | 玩更多同类游戏 |
| 2D美术 | 基础 | ___ | 使用现成资源/简化风格 |
| 音效制作 | 入门 | ___ | 使用免费音效库 |
| 项目管理 | 基础 | ___ | 使用敏捷方法 |

### 1.5 最小可行产品（MVP）定义

**第一版本必须包含：**
1. 基本移动系统
2. 回旋镖投掷与返回
3. 碰撞与伤害
4. 1个测试地图
5. 2个玩家对战
6. 基础UI

**可以后续添加：**
- AI对手
- 更多地图
- 道具系统
- 角色选择
- 音效音乐

---

## 2. 产品设计与核心玩法

### 2.1 核心循环设计

```
开始回合 → 玩家移动/躲避 → 寻找时机 → 投掷回旋镖
    ↑                                      ↓
    ←  判定胜负  ←  击中/未中  ←  回旋镖飞行
```

### 2.2 控制方案设计

#### 键盘控制（玩家1）
```
移动：WASD
投掷：Space
冲刺：Shift（可选）
```

#### 键盘控制（玩家2）
```
移动：方向键
投掷：Enter
冲刺：右Ctrl（可选）
```

#### 手柄控制
```
移动：左摇杆
投掷：A/X按钮
冲刺：肩键
```

### 2.3 游戏规则设计

#### 基础规则
- **生命值**：每个玩家3条命
- **回合制**：最后存活者获胜
- **时间限制**：每回合3分钟，超时判定平局

#### 回旋镖机制
```rust
// 回旋镖的核心参数
pub struct BoomerangConfig {
    pub throw_speed: f32,      // 投掷速度：600 像素/秒
    pub return_speed: f32,     // 返回速度：800 像素/秒
    pub max_distance: f32,     // 最大飞行距离：400 像素
    pub curve_factor: f32,     // 弧线系数：0.3
    pub spin_speed: f32,       // 旋转速度：10 弧度/秒
    pub damage: i32,           // 伤害值：1
    pub knockback: f32,        // 击退力度：200
}
```

#### 特殊机制
1. **接住回旋镖**：站在返回路径上可以提前接住
2. **反弹机制**：击中墙壁会改变方向
3. **连击系统**：快速击败多个敌人获得加分
4. **无敌帧**：被击中后0.5秒无敌时间

### 2.4 道具系统设计

| 道具名称 | 效果 | 持续时间 | 稀有度 |
|---------|------|---------|--------|
| 多重回旋镖 | 同时投掷3个 | 1次 | 常见 |
| 巨型回旋镖 | 体积x2，伤害x2 | 30秒 | 稀有 |
| 传送门 | 回旋镖可穿墙 | 15秒 | 稀有 |
| 护盾 | 抵挡1次攻击 | 直到破碎 | 常见 |
| 加速鞋 | 移速x1.5 | 20秒 | 常见 |

### 2.5 角色设计

保持简单，先做4个差异化角色：

| 角色 | 特点 | 速度 | 投掷力 | 生命 |
|-----|------|-----|--------|-----|
| 忍者 | 均衡型 | 100% | 100% | 3 |
| 武士 | 力量型 | 80% | 120% | 4 |
| 弓箭手 | 速度型 | 120% | 90% | 2 |
| 法师 | 技巧型 | 90% | 100% | 3 |

### 2.6 地图设计原则

#### 地图要素
1. **尺寸**：20x15 格子（适合2-4人）
2. **墙体**：可破坏/不可破坏两种
3. **障碍物**：影响回旋镖轨迹
4. **道具点**：固定刷新位置
5. **陷阱**：增加变数（可选）

#### 6张核心地图主题
1. **竞技场**：标准对称地图
2. **迷宫**：复杂路径，重策略
3. **开阔地**：少障碍，重操作
4. **丛林**：多掩体，游击战
5. **冰面**：滑动地形，增加难度
6. **随机**：程序生成

---

## 3. 技术架构设计

### 3.1 项目结构

```
boomerang-battle/
├── src/
│   ├── main.rs              # 游戏入口
│   ├── game/
│   │   ├── mod.rs           # 游戏核心模块
│   │   ├── player.rs        # 玩家系统
│   │   ├── boomerang.rs     # 回旋镖系统
│   │   ├── combat.rs        # 战斗系统
│   │   └── powerup.rs       # 道具系统
│   ├── physics/
│   │   ├── mod.rs           # 物理模块
│   │   ├── collision.rs     # 碰撞检测
│   │   └── movement.rs      # 移动系统
│   ├── ai/
│   │   ├── mod.rs           # AI模块
│   │   ├── behavior.rs      # 行为树
│   │   └── pathfinding.rs   # 寻路系统
│   ├── ui/
│   │   ├── mod.rs           # UI模块
│   │   ├── menu.rs          # 菜单系统
│   │   ├── hud.rs           # HUD显示
│   │   └── scoreboard.rs    # 计分板
│   ├── level/
│   │   ├── mod.rs           # 关卡模块
│   │   ├── map.rs           # 地图加载
│   │   └── generator.rs     # 地图生成
│   ├── audio/
│   │   ├── mod.rs           # 音频模块
│   │   └── manager.rs       # 音效管理
│   └── utils/
│       ├── mod.rs           # 工具模块
│       ├── math.rs          # 数学工具
│       └── debug.rs         # 调试工具
├── assets/                   # 游戏资源
│   ├── sprites/             # 图片资源
│   ├── audio/               # 音频资源
│   ├── fonts/               # 字体资源
│   └── maps/                # 地图数据
├── Cargo.toml               # 项目配置
└── README.md                # 项目说明
```

### 3.2 核心组件设计

```rust
// 玩家组件
#[derive(Component)]
pub struct Player {
    pub id: u8,
    pub lives: i32,
    pub score: i32,
    pub character_type: CharacterType,
    pub power_ups: Vec<PowerUpType>,
}

// 回旋镖组件
#[derive(Component)]
pub struct Boomerang {
    pub owner: Entity,
    pub damage: i32,
    pub state: BoomerangState,
    pub throw_direction: Vec2,
    pub traveled_distance: f32,
    pub max_distance: f32,
}

#[derive(Clone, Copy, PartialEq)]
pub enum BoomerangState {
    Held,        // 持有状态
    Thrown,      // 投掷状态
    Returning,   // 返回状态
}

// 移动组件
#[derive(Component)]
pub struct Velocity(pub Vec2);

#[derive(Component)]
pub struct Moveable {
    pub speed: f32,
    pub acceleration: f32,
    pub friction: f32,
}

// 碰撞组件
#[derive(Component)]
pub struct Collider {
    pub size: Vec2,
    pub offset: Vec2,
    pub is_trigger: bool,
}

// 生命组件
#[derive(Component)]
pub struct Health {
    pub current: i32,
    pub max: i32,
    pub invulnerable_until: Option<f32>,
}
```

### 3.3 系统架构

```rust
// 游戏状态
#[derive(States, Default, Clone, Eq, PartialEq, Debug, Hash)]
pub enum GameState {
    #[default]
    MainMenu,
    CharacterSelect,
    InGame,
    Paused,
    GameOver,
}

// 插件组织
pub struct GamePlugin;

impl Plugin for GamePlugin {
    fn build(&self, app: &mut App) {
        app
            // 状态
            .init_state::<GameState>()
            
            // 资源
            .init_resource::<GameSettings>()
            .init_resource::<InputManager>()
            
            // 事件
            .add_event::<DamageEvent>()
            .add_event::<ThrowBoomerangEvent>()
            .add_event::<PickupPowerUpEvent>()
            
            // 系统 - 按执行顺序
            .add_systems(Update, (
                // 输入阶段
                handle_player_input,
                handle_ai_input,
                
                // 更新阶段
                update_movement,
                update_boomerang_physics,
                update_animations,
                
                // 碰撞阶段
                check_collisions,
                resolve_collisions,
                
                // 游戏逻辑
                apply_damage,
                check_win_condition,
                spawn_powerups,
                
                // 渲染准备
                update_camera,
                sort_sprites,
            ).chain().run_if(in_state(GameState::InGame)))
            
            // UI系统
            .add_systems(Update, (
                update_hud,
                update_scoreboard,
            ).run_if(in_state(GameState::InGame)));
    }
}
```

### 3.4 依赖配置

```toml
# Cargo.toml
[package]
name = "boomerang-battle"
version = "0.1.0"
edition = "2021"

[dependencies]
# 核心引擎
bevy = "0.15"

# 物理引擎
avian2d = "0.2"

# 数学工具
bevy_math = "0.15"

# UI增强
bevy_egui = "0.31"

# 音频
bevy_kira_audio = "0.21"

# 动画
bevy_tweening = "0.12"

# 粒子效果
bevy_hanabi = "0.13"

# 开发工具
bevy-inspector-egui = { version = "0.27", optional = true }

# 序列化
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"

# 随机数
rand = "0.8"

# 路径查找
pathfinding = "4.11"

[features]
default = []
dev = ["bevy-inspector-egui"]

[profile.dev]
opt-level = 1

[profile.release]
lto = true
codegen-units = 1
```

---

## 4. 项目管理与时间规划

### 4.1 开发阶段划分

#### 总时间预估：3个月（全职）/ 6个月（业余）

| 阶段 | 时长 | 主要任务 | 可交付成果 |
|-----|------|---------|-----------|
| **阶段1：原型** | 2周 | 基础移动、投掷 | 可控制的角色 |
| **阶段2：核心玩法** | 3周 | 回旋镖物理、碰撞 | 能战斗的demo |
| **阶段3：游戏循环** | 2周 | 生命、计分、回合 | 完整游戏流程 |
| **阶段4：内容制作** | 3周 | 地图、角色、道具 | 丰富的游戏内容 |
| **阶段5：AI系统** | 2周 | 基础AI、寻路 | 单人可玩 |
| **阶段6：UI界面** | 2周 | 菜单、HUD、设置 | 完整用户界面 |
| **阶段7：音效音乐** | 1周 | 音效集成、BGM | 声音反馈 |
| **阶段8：优化打磨** | 2周 | 性能、手感、平衡 | 流畅体验 |
| **阶段9：测试修复** | 1周 | Bug修复、平衡调整 | 稳定版本 |

### 4.2 每日开发计划

#### 高效的4小时工作块（业余开发者）

```
19:00-19:30  回顾昨日进度，制定今日目标
19:30-21:00  核心开发（编程）
21:00-21:15  休息
21:15-22:15  测试与调试
22:15-22:30  记录进度，提交代码
22:30-23:00  学习/研究（可选）
```

#### 全职开发的8小时安排

```
09:00-09:30  计划与准备
09:30-11:30  核心功能开发
11:30-13:00  午休
13:00-15:00  功能开发续
15:00-15:30  测试当日功能
15:30-17:00  内容制作/优化
17:00-17:30  文档更新，代码提交
```

### 4.3 里程碑设置

#### 里程碑1：可玩原型（第2周末）
- [ ] 角色能移动
- [ ] 能投掷物体
- [ ] 基础碰撞检测
- [ ] 临时美术资源

#### 里程碑2：核心战斗（第5周末）
- [ ] 回旋镖完整机制
- [ ] 伤害与死亡
- [ ] 基础地图
- [ ] 2人对战

#### 里程碑3：完整流程（第7周末）
- [ ] 游戏开始到结束
- [ ] 多回合系统
- [ ] 胜负判定
- [ ] 基础UI

#### 里程碑4：内容完善（第10周末）
- [ ] 4个角色
- [ ] 6张地图
- [ ] 5种道具
- [ ] AI对手

#### 里程碑5：发布版本（第13周末）
- [ ] 完整UI
- [ ] 音效音乐
- [ ] 性能优化
- [ ] 无重大bug

### 4.4 风险管理

| 风险项 | 可能性 | 影响 | 应对策略 |
|-------|--------|------|---------|
| 回旋镖物理实现困难 | 高 | 高 | 先用简化版，逐步优化 |
| AI编写复杂 | 高 | 中 | 使用简单状态机，不追求完美 |
| 美术资源不足 | 中 | 中 | 使用免费资源/极简风格 |
| 性能问题 | 中 | 高 | 持续性能测试，及时优化 |
| 失去动力 | 中 | 高 | 设置小目标，寻找反馈 |
| 时间不足 | 高 | 中 | 削减非核心功能 |

### 4.5 版本管理策略

```bash
# Git 分支策略
main          # 稳定版本
develop       # 开发分支
feature/xxx   # 功能分支
bugfix/xxx    # 修复分支

# 提交信息规范
feat: 添加回旋镖返回机制
fix: 修复碰撞检测边界问题
docs: 更新README
style: 格式化代码
refactor: 重构移动系统
test: 添加物理测试
chore: 更新依赖

# 版本号规则
0.1.0 - 原型版本
0.2.0 - 核心玩法
0.3.0 - 完整流程
0.4.0 - 内容完善
0.5.0 - Beta版本
1.0.0 - 正式发布
```

---

## 5. 美术风格与资源制作

### 5.1 美术风格选择

考虑独立开发者的能力限制，推荐以下风格：

#### 方案A：像素风格（推荐）
- **优点**：制作简单，风格统一，有复古魅力
- **缺点**：细节表现有限
- **参考**：Enter the Gungeon, Katana ZERO

```
角色尺寸：32x32 像素
地图瓦片：16x16 像素
UI元素：可缩放矢量
```

#### 方案B：几何简约风
- **优点**：无需绘画技能，现代感强
- **缺点**：容易显得单调
- **参考**：Superhot, Mirror's Edge

```rust
// 用代码生成几何图形
fn create_character_sprite() -> Mesh {
    // 身体：圆形
    let body = Circle::new(20.0);
    // 手臂：矩形
    let arms = Rectangle::new(30.0, 5.0);
    // 组合
    combine_meshes(body, arms)
}
```

### 5.2 美术资源清单

#### 必需资源（MVP）

| 类型 | 数量 | 规格 | 制作方法 |
|-----|------|-----|---------|
| 角色精灵 | 4个 | 32x32，4方向 | Aseprite |
| 回旋镖 | 1个 | 16x16，旋转动画 | Aseprite |
| 地图瓦片 | 20种 | 16x16 | Tiled编辑器 |
| UI按钮 | 10个 | 可缩放 | Figma |
| 特效 | 5种 | 精灵序列 | Aseprite |
| 图标 | 20个 | 32x32 | Figma |

#### 动画需求

```rust
// 角色动画状态
pub enum AnimationState {
    Idle,       // 4帧循环
    Walk,       // 6帧循环
    Throw,      // 3帧，不循环
    Hit,        // 2帧，不循环
    Death,      // 4帧，不循环
}

// 动画配置
pub struct AnimationConfig {
    pub frames: Vec<usize>,
    pub duration: f32,  // 每帧时长
    pub looping: bool,
}
```

### 5.3 免费资源推荐

#### 图像资源
- **OpenGameArt.org** - 大量免费游戏美术
- **Itch.io Assets** - 付费/免费资源包
- **Kenney.nl** - 高质量免费资源
- **CraftPix.net** - 部分免费资源

#### 具体资源包
1. **Kenney's Tiny Dungeon** - 适合的角色和地图
2. **0x72 DungeonTileset** - 优秀的像素地牢资源
3. **Pixel Frog Assets** - 可爱的像素角色

### 5.4 美术制作工具

#### 像素画工具
```
Aseprite（付费，推荐）
  - 专业像素画工具
  - 完美的动画支持
  - $20

Piskel（免费）
  - 在线像素画工具
  - 基础功能齐全
  
GraphicsGale（免费）
  - Windows像素画工具
  - 功能完整
```

#### 地图编辑器
```
Tiled（免费，推荐）
  - 通用地图编辑器
  - 支持导出JSON
  - Bevy有现成加载器

LDTK（免费）
  - 现代地图编辑器
  - 更强大的功能
  - Bevy集成良好
```

### 5.5 美术制作流程

#### 第一步：确定调色板
```rust
// 定义游戏的颜色主题
pub struct ColorPalette {
    pub background: Color,      // #2C3E50
    pub primary: Color,          // #3498DB
    pub secondary: Color,        // #E74C3C
    pub accent: Color,           // #F39C12
    pub text: Color,             // #ECF0F1
    pub shadow: Color,           // #1A252F
}
```

#### 第二步：制作基础精灵
1. 创建角色基础形状
2. 添加特征细节
3. 制作4方向视图
4. 创建动画帧

#### 第三步：制作地图瓦片
1. 基础地面瓦片
2. 墙体瓦片（边角）
3. 装饰瓦片
4. 特殊瓦片（道具点等）

#### 第四步：特效制作
```
爆炸效果：8帧扩散动画
击中效果：4帧闪光
道具拾取：6帧光环扩散
死亡效果：粒子消散
回旋镖轨迹：拖尾效果
```

---

## 6. 音效与音乐设计

### 6.1 音效需求列表

#### 核心音效（必需）

| 音效类型 | 数量 | 描述 | 来源建议 |
|---------|------|------|---------|
| 移动音效 | 2 | 脚步声（走/跑） | Freesound |
| 投掷音效 | 1 | 嗖的一声 | Sfxr生成 |
| 击中音效 | 3 | 不同材质 | Sfxr生成 |
| 受伤音效 | 2 | 角色受伤 | Freesound |
| 死亡音效 | 1 | 角色死亡 | Sfxr生成 |
| 拾取音效 | 2 | 道具/回旋镖 | Sfxr生成 |
| UI音效 | 3 | 点击/悬停/确认 | Sfxr生成 |
| 环境音效 | 2 | 破坏/碰撞 | Freesound |

### 6.2 音乐需求

#### 最小音乐集
1. **主菜单BGM** - 轻松欢快，循环
2. **战斗BGM** - 紧张激烈，循环
3. **胜利音乐** - 短促欢快，单次
4. **失败音乐** - 低沉，单次

### 6.3 免费音频资源

#### 音效库
- **Freesound.org** - 最大的免费音效库
- **Zapsplat.com** - 需要免费注册
- **Soundbible.com** - 完全免费
- **OpenGameArt.org** - 游戏音效

#### 音乐资源
- **Incompetech.com** - Kevin MacLeod的免费音乐
- **Bensound.com** - 免费背景音乐
- **FreeMusicArchive.org** - 各种免费音乐
- **OpenGameArt.org** - 游戏音乐

#### 音效生成工具
```
Sfxr（原版）
  - 经典8-bit音效生成器
  
Bfxr（增强版）
  - 更多参数和预设
  - 在线版本可用
  
ChipTone（在线）
  - 现代化界面
  - 更多音效类型
  
LabChirp（高级）
  - 更复杂的音效
  - 适合特殊效果
```

### 6.4 音频实现代码

```rust
use bevy_kira_audio::prelude::*;

// 音频资源
#[derive(Resource)]
pub struct GameAudio {
    pub bgm_handle: Handle<AudioSource>,
    pub sfx_handles: HashMap<String, Handle<AudioSource>>,
}

// 音频设置
#[derive(Resource)]
pub struct AudioSettings {
    pub master_volume: f32,
    pub bgm_volume: f32,
    pub sfx_volume: f32,
    pub muted: bool,
}

// 播放音效系统
fn play_sound_effects(
    audio: Res<Audio>,
    game_audio: Res<GameAudio>,
    settings: Res<AudioSettings>,
    mut events: EventReader<SoundEvent>,
) {
    for event in events.read() {
        if !settings.muted {
            if let Some(handle) = game_audio.sfx_handles.get(&event.name) {
                audio.play(handle.clone())
                    .with_volume(settings.sfx_volume * settings.master_volume);
            }
        }
    }
}

// 音效事件
#[derive(Event)]
pub struct SoundEvent {
    pub name: String,
    pub position: Option<Vec2>,  // 用于3D音效定位
}

// 音乐管理
fn manage_background_music(
    audio: Res<AudioChannel<BackgroundMusic>>,
    game_state: Res<State<GameState>>,
    mut last_state: Local<GameState>,
) {
    if *game_state.get() != *last_state {
        match game_state.get() {
            GameState::MainMenu => {
                audio.stop();
                audio.play_looped(menu_music_handle.clone());
            }
            GameState::InGame => {
                audio.stop();
                audio.play_looped(battle_music_handle.clone());
            }
            _ => {}
        }
        *last_state = game_state.get().clone();
    }
}
```

### 6.5 音频优化建议

1. **预加载**：游戏启动时加载所有音效
2. **对象池**：复用音频实例
3. **音频压缩**：使用OGG格式，平衡质量和大小
4. **动态加载**：按需加载大型音乐文件
5. **音效分层**：重要音效优先级更高

---

## 7. 核心系统实现

### 7.1 玩家控制系统

```rust
// 输入映射
#[derive(Resource)]
pub struct InputMapping {
    pub player_1: PlayerControls,
    pub player_2: PlayerControls,
}

#[derive(Clone)]
pub struct PlayerControls {
    pub up: KeyCode,
    pub down: KeyCode,
    pub left: KeyCode,
    pub right: KeyCode,
    pub throw: KeyCode,
    pub dash: KeyCode,
}

impl Default for InputMapping {
    fn default() -> Self {
        Self {
            player_1: PlayerControls {
                up: KeyCode::KeyW,
                down: KeyCode::KeyS,
                left: KeyCode::KeyA,
                right: KeyCode::KeyD,
                throw: KeyCode::Space,
                dash: KeyCode::ShiftLeft,
            },
            player_2: PlayerControls {
                up: KeyCode::ArrowUp,
                down: KeyCode::ArrowDown,
                left: KeyCode::ArrowLeft,
                right: KeyCode::ArrowRight,
                throw: KeyCode::Enter,
                dash: KeyCode::ControlRight,
            },
        }
    }
}

// 输入处理系统
fn handle_player_input(
    keyboard: Res<ButtonInput<KeyCode>>,
    input_mapping: Res<InputMapping>,
    mut players: Query<(&Player, &mut Velocity, &Transform, &mut ActionState)>,
    mut throw_events: EventWriter<ThrowBoomerangEvent>,
    time: Res<Time>,
) {
    for (player, mut velocity, transform, mut action_state) in players.iter_mut() {
        let controls = match player.id {
            0 => &input_mapping.player_1,
            1 => &input_mapping.player_2,
            _ => continue,
        };
        
        // 移动输入
        let mut move_direction = Vec2::ZERO;
        
        if keyboard.pressed(controls.up) {
            move_direction.y += 1.0;
        }
        if keyboard.pressed(controls.down) {
            move_direction.y -= 1.0;
        }
        if keyboard.pressed(controls.left) {
            move_direction.x -= 1.0;
        }
        if keyboard.pressed(controls.right) {
            move_direction.x += 1.0;
        }
        
        // 归一化移动方向
        if move_direction.length() > 0.0 {
            move_direction = move_direction.normalize();
            velocity.0 = move_direction * player.move_speed;
            action_state.facing_direction = move_direction;
        } else {
            // 应用摩擦力
            velocity.0 *= 0.9;
        }
        
        // 投掷输入
        if keyboard.just_pressed(controls.throw) && action_state.can_throw() {
            throw_events.send(ThrowBoomerangEvent {
                player_entity: player_entity,
                direction: action_state.facing_direction,
                power: 1.0,
            });
            action_state.last_throw_time = time.elapsed_secs();
        }
        
        // 冲刺输入
        if keyboard.just_pressed(controls.dash) && action_state.can_dash() {
            velocity.0 = action_state.facing_direction * player.dash_speed;
            action_state.is_dashing = true;
            action_state.dash_timer = 0.2; // 冲刺持续0.2秒
        }
    }
}
```

### 7.2 回旋镖系统实现

```rust
// 回旋镖组件
#[derive(Component)]
pub struct Boomerang {
    pub owner: Entity,
    pub damage: i32,
    pub throw_direction: Vec2,
    pub state: BoomerangState,
    pub flight_time: f32,
    pub max_distance: f32,
    pub traveled_distance: f32,
    pub return_speed_multiplier: f32,
    pub spin_rate: f32,
    pub bounces_remaining: i32,
}

#[derive(Clone, Copy, PartialEq)]
pub enum BoomerangState {
    Held,
    Thrown,
    Returning,
    Caught,
}

// 投掷事件
#[derive(Event)]
pub struct ThrowBoomerangEvent {
    pub player_entity: Entity,
    pub direction: Vec2,
    pub power: f32,
}

// 投掷处理系统
fn handle_throw_boomerang(
    mut commands: Commands,
    mut events: EventReader<ThrowBoomerangEvent>,
    mut players: Query<(&Transform, &mut Player, &Children)>,
    mut boomerangs: Query<&mut Boomerang>,
    asset_server: Res<AssetServer>,
) {
    for event in events.read() {
        if let Ok((transform, mut player, children)) = players.get_mut(event.player_entity) {
            // 检查是否已有回旋镖在飞行
            let has_flying_boomerang = children.iter().any(|&child| {
                if let Ok(boomerang) = boomerangs.get(child) {
                    boomerang.state != BoomerangState::Held
                } else {
                    false
                }
            });
            
            if has_flying_boomerang {
                continue; // 已有回旋镖在飞行，不能投掷
            }
            
            // 创建新回旋镖
            let boomerang_entity = commands.spawn((
                Boomerang {
                    owner: event.player_entity,
                    damage: 1,
                    throw_direction: event.direction,
                    state: BoomerangState::Thrown,
                    flight_time: 0.0,
                    max_distance: 400.0 * event.power,
                    traveled_distance: 0.0,
                    return_speed_multiplier: 1.5,
                    spin_rate: 10.0,
                    bounces_remaining: 2,
                },
                Transform::from_translation(transform.translation),
                Velocity(event.direction * 600.0 * event.power),
                Sprite {
                    texture: asset_server.load("sprites/boomerang.png"),
                    ..default()
                },
                Collider {
                    size: Vec2::new(24.0, 24.0),
                    offset: Vec2::ZERO,
                    is_trigger: true,
                },
            )).id();
            
            // 播放投掷音效
            audio_events.send(SoundEvent {
                name: "throw".to_string(),
                position: Some(transform.translation.truncate()),
            });
        }
    }
}

// 回旋镖物理更新
fn update_boomerang_physics(
    mut boomerangs: Query<(
        Entity,
        &mut Boomerang,
        &mut Transform,
        &mut Velocity,
    )>,
    players: Query<&Transform, (With<Player>, Without<Boomerang>)>,
    time: Res<Time>,
    mut commands: Commands,
) {
    let dt = time.delta_secs();
    
    for (entity, mut boomerang, mut transform, mut velocity) in boomerangs.iter_mut() {
        boomerang.flight_time += dt;
        
        match boomerang.state {
            BoomerangState::Thrown => {
                // 更新位置
                let movement = velocity.0 * dt;
                transform.translation.x += movement.x;
                transform.translation.y += movement.y;
                boomerang.traveled_distance += movement.length();
                
                // 旋转效果
                transform.rotation = Quat::from_rotation_z(
                    transform.rotation.to_euler(EulerRot::ZYX).0 + boomerang.spin_rate * dt
                );
                
                // 检查是否达到最大距离
                if boomerang.traveled_distance >= boomerang.max_distance {
                    boomerang.state = BoomerangState::Returning;
                    boomerang.traveled_distance = 0.0;
                }
                
                // 添加轻微的弧线效果
                let curve_factor = (boomerang.flight_time * 3.0).sin() * 50.0;
                let perpendicular = Vec2::new(-velocity.0.y, velocity.0.x).normalize();
                transform.translation.x += perpendicular.x * curve_factor * dt;
                transform.translation.y += perpendicular.y * curve_factor * dt;
            }
            
            BoomerangState::Returning => {
                // 找到主人位置
                if let Ok(owner_transform) = players.get(boomerang.owner) {
                    let to_owner = owner_transform.translation - transform.translation;
                    let distance = to_owner.length();
                    
                    if distance < 30.0 {
                        // 被接住了
                        boomerang.state = BoomerangState::Caught;
                        commands.entity(entity).despawn();
                        
                        // 播放接住音效
                        audio_events.send(SoundEvent {
                            name: "catch".to_string(),
                            position: Some(transform.translation.truncate()),
                        });
                    } else {
                        // 向主人飞行
                        let return_direction = to_owner.normalize();
                        let return_speed = 800.0 * boomerang.return_speed_multiplier;
                        velocity.0 = return_direction.truncate() * return_speed;
                        
                        // 更新位置
                        transform.translation.x += velocity.0.x * dt;
                        transform.translation.y += velocity.0.y * dt;
                        
                        // 继续旋转
                        transform.rotation = Quat::from_rotation_z(
                            transform.rotation.to_euler(EulerRot::ZYX).0 + boomerang.spin_rate * 1.5 * dt
                        );
                    }
                }
            }
            
            _ => {}
        }
    }
}

// 回旋镖碰撞处理
fn handle_boomerang_collision(
    mut boomerangs: Query<(&mut Boomerang, &Transform, &mut Velocity)>,
    mut players: Query<(&mut Health, &Transform, &Player)>,
    walls: Query<&Transform, (With<Wall>, Without<Boomerang>, Without<Player>)>,
    mut damage_events: EventWriter<DamageEvent>,
) {
    for (mut boomerang, boomerang_transform, mut velocity) in boomerangs.iter_mut() {
        let boomerang_pos = boomerang_transform.translation.truncate();
        
        // 检查与玩家的碰撞
        for (mut health, player_transform, player) in players.iter_mut() {
            // 不能击中自己
            if player.entity == boomerang.owner {
                continue;
            }
            
            let player_pos = player_transform.translation.truncate();
            let distance = boomerang_pos.distance(player_pos);
            
            if distance < 30.0 && health.current > 0 {
                damage_events.send(DamageEvent {
                    target: player.entity,
                    damage: boomerang.damage,
                    knockback: velocity.0.normalize() * 200.0,
                });
                
                // 回旋镖击中后改变状态
                if boomerang.state == BoomerangState::Thrown {
                    boomerang.state = BoomerangState::Returning;
                }
            }
        }
        
        // 检查与墙壁的碰撞
        for wall_transform in walls.iter() {
            let wall_pos = wall_transform.translation.truncate();
            let distance = boomerang_pos.distance(wall_pos);
            
            if distance < 25.0 && boomerang.bounces_remaining > 0 {
                // 计算反弹
                let normal = (boomerang_pos - wall_pos).normalize();
                velocity.0 = velocity.0 - 2.0 * velocity.0.dot(normal) * normal;
                velocity.0 *= 0.8; // 能量损失
                boomerang.bounces_remaining -= 1;
                
                // 播放反弹音效
                audio_events.send(SoundEvent {
                    name: "bounce".to_string(),
                    position: Some(boomerang_pos),
                });
            }
        }
    }
}
```

### 7.3 战斗系统

```rust
// 伤害事件
#[derive(Event)]
pub struct DamageEvent {
    pub target: Entity,
    pub damage: i32,
    pub knockback: Vec2,
    pub source: Option<Entity>,
}

// 处理伤害
fn apply_damage(
    mut events: EventReader<DamageEvent>,
    mut players: Query<(&mut Health, &mut Velocity, &Player)>,
    time: Res<Time>,
    mut game_events: EventWriter<PlayerDeathEvent>,
) {
    let current_time = time.elapsed_secs();
    
    for event in events.read() {
        if let Ok((mut health, mut velocity, player)) = players.get_mut(event.target) {
            // 检查无敌时间
            if let Some(invulnerable_until) = health.invulnerable_until {
                if current_time < invulnerable_until {
                    continue; // 还在无敌时间内
                }
            }
            
            // 应用伤害
            health.current = (health.current - event.damage).max(0);
            
            // 应用击退
            velocity.0 += event.knockback;
            
            // 设置无敌时间
            health.invulnerable_until = Some(current_time + 0.5);
            
            // 播放受伤音效
            audio_events.send(SoundEvent {
                name: "hit".to_string(),
                position: Some(transform.translation.truncate()),
            });
            
            // 检查死亡
            if health.current <= 0 {
                game_events.send(PlayerDeathEvent {
                    player_id: player.id,
                    killer: event.source,
                });
            }
        }
    }
}

// 无敌闪烁效果
fn invulnerability_visual(
    mut players: Query<(&Health, &mut Sprite)>,
    time: Res<Time>,
) {
    let current_time = time.elapsed_secs();
    
    for (health, mut sprite) in players.iter_mut() {
        if let Some(invulnerable_until) = health.invulnerable_until {
            if current_time < invulnerable_until {
                // 闪烁效果
                let alpha = if (current_time * 10.0) as i32 % 2 == 0 {
                    0.3
                } else {
                    1.0
                };
                sprite.color.set_alpha(alpha);
            } else {
                sprite.color.set_alpha(1.0);
            }
        }
    }
}
```

---

## 8. 物理与碰撞系统

### 8.1 碰撞检测实现

```rust
use avian2d::prelude::*;

// 碰撞层定义
#[derive(PhysicsLayer)]
pub enum CollisionLayer {
    Player,      // 0b00001
    Boomerang,   // 0b00010
    Wall,        // 0b00100
    PowerUp,     // 0b01000
    Destructible,// 0b10000
}

// 配置物理世界
pub fn setup_physics(mut commands: Commands) {
    // 设置重力（俯视角，无重力）
    commands.insert_resource(Gravity(Vec2::ZERO));
    
    // 物理配置
    commands.insert_resource(PhysicsTimestep::Fixed(
        FixedTime::from_hz(60.0)
    ));
}

// 简单AABB碰撞检测（备用方案）
fn check_aabb_collision(a_pos: Vec2, a_size: Vec2, b_pos: Vec2, b_size: Vec2) -> bool {
    let a_min = a_pos - a_size / 2.0;
    let a_max = a_pos + a_size / 2.0;
    let b_min = b_pos - b_size / 2.0;
    let b_max = b_pos + b_size / 2.0;
    
    a_min.x < b_max.x &&
    a_max.x > b_min.x &&
    a_min.y < b_max.y &&
    a_max.y > b_min.y
}

// 圆形碰撞检测
fn check_circle_collision(a_pos: Vec2, a_radius: f32, b_pos: Vec2, b_radius: f32) -> bool {
    let distance = a_pos.distance(b_pos);
    distance < a_radius + b_radius
}

// 空间划分优化
#[derive(Resource)]
pub struct SpatialGrid {
    cell_size: f32,
    cells: HashMap<(i32, i32), Vec<Entity>>,
}

impl SpatialGrid {
    pub fn new(cell_size: f32) -> Self {
        Self {
            cell_size,
            cells: HashMap::new(),
        }
    }
    
    pub fn clear(&mut self) {
        self.cells.clear();
    }
    
    pub fn insert(&mut self, entity: Entity, position: Vec2) {
        let cell = self.get_cell(position);
        self.cells.entry(cell).or_insert_with(Vec::new).push(entity);
    }
    
    pub fn get_nearby(&self, position: Vec2) -> Vec<Entity> {
        let mut nearby = Vec::new();
        let (cx, cy) = self.get_cell(position);
        
        // 检查周围9个格子
        for dx in -1..=1 {
            for dy in -1..=1 {
                if let Some(entities) = self.cells.get(&(cx + dx, cy + dy)) {
                    nearby.extend(entities);
                }
            }
        }
        
        nearby
    }
    
    fn get_cell(&self, position: Vec2) -> (i32, i32) {
        (
            (position.x / self.cell_size).floor() as i32,
            (position.y / self.cell_size).floor() as i32,
        )
    }
}
```

### 8.2 移动系统

```rust
// 移动组件
#[derive(Component)]
pub struct Movement {
    pub velocity: Vec2,
    pub acceleration: Vec2,
    pub max_speed: f32,
    pub friction: f32,
}

// 更新移动
fn update_movement(
    mut movers: Query<(&mut Transform, &mut Movement)>,
    time: Res<Time>,
) {
    let dt = time.delta_secs();
    
    for (mut transform, mut movement) in movers.iter_mut() {
        // 应用加速度
        movement.velocity += movement.acceleration * dt;
        
        // 限制最大速度
        if movement.velocity.length() > movement.max_speed {
            movement.velocity = movement.velocity.normalize() * movement.max_speed;
        }
        
        // 应用速度
        transform.translation.x += movement.velocity.x * dt;
        transform.translation.y += movement.velocity.y * dt;
        
        // 应用摩擦力
        movement.velocity *= 1.0 - movement.friction * dt;
        
        // 重置加速度
        movement.acceleration = Vec2::ZERO;
    }
}

// 碰撞响应
fn resolve_collisions(
    mut players: Query<(&mut Transform, &Collider), With<Player>>,
    walls: Query<(&Transform, &Collider), (With<Wall>, Without<Player>)>,
) {
    for (mut player_transform, player_collider) in players.iter_mut() {
        let player_pos = player_transform.translation.truncate();
        
        for (wall_transform, wall_collider) in walls.iter() {
            let wall_pos = wall_transform.translation.truncate();
            
            if check_aabb_collision(
                player_pos,
                player_collider.size,
                wall_pos,
                wall_collider.size,
            ) {
                // 计算推出方向
                let diff = player_pos - wall_pos;
                let overlap_x = (player_collider.size.x + wall_collider.size.x) / 2.0 - diff.x.abs();
                let overlap_y = (player_collider.size.y + wall_collider.size.y) / 2.0 - diff.y.abs();
                
                // 推出较小的重叠轴
                if overlap_x < overlap_y {
                    player_transform.translation.x += overlap_x * diff.x.signum();
                } else {
                    player_transform.translation.y += overlap_y * diff.y.signum();
                }
            }
        }
    }
}
```

---

## 9. AI系统设计

### 9.1 AI行为树

```rust
// AI状态
#[derive(Component, Debug, Clone)]
pub enum AIState {
    Idle,
    Chasing,
    Attacking,
    Dodging,
    Collecting,
    Fleeing,
}

// AI组件
#[derive(Component)]
pub struct AIController {
    pub state: AIState,
    pub target: Option<Entity>,
    pub last_attack_time: f32,
    pub reaction_time: f32,
    pub skill_level: SkillLevel,
    pub decision_timer: f32,
}

#[derive(Clone, Copy)]
pub enum SkillLevel {
    Easy,    // 反应慢，准确度低
    Medium,  // 平衡
    Hard,    // 反应快，准确度高
}

// AI决策系统
fn ai_decision_system(
    mut ai_controllers: Query<(
        Entity,
        &mut AIController,
        &Transform,
        &Health,
        &Player,
    )>,
    all_players: Query<(Entity, &Transform, &Health), With<Player>>,
    boomerangs: Query<(&Boomerang, &Transform, &Velocity)>,
    powerups: Query<(&Transform, &PowerUp)>,
    time: Res<Time>,
) {
    let current_time = time.elapsed_secs();
    
    for (ai_entity, mut ai, ai_transform, ai_health, ai_player) in ai_controllers.iter_mut() {
        ai.decision_timer -= time.delta_secs();
        
        if ai.decision_timer > 0.0 {
            continue; // 还没到决策时间
        }
        
        // 根据技能等级设置决策频率
        ai.decision_timer = match ai.skill_level {
            SkillLevel::Easy => 0.5,
            SkillLevel::Medium => 0.3,
            SkillLevel::Hard => 0.1,
        };
        
        let ai_pos = ai_transform.translation.truncate();
        
        // 评估威胁
        let mut nearest_threat: Option<(Entity, f32, ThreatType)> = None;
        
        // 检查飞行中的回旋镖
        for (boomerang, boom_transform, velocity) in boomerangs.iter() {
            if boomerang.owner == ai_entity {
                continue; // 自己的回旋镖
            }
            
            let boom_pos = boom_transform.translation.truncate();
            let distance = ai_pos.distance(boom_pos);
            
            // 预测回旋镖轨迹
            let future_pos = boom_pos + velocity.0.normalize() * 50.0;
            let future_distance = ai_pos.distance(future_pos);
            
            if future_distance < 100.0 {
                nearest_threat = Some((
                    boomerang.owner,
                    future_distance,
                    ThreatType::Boomerang,
                ));
            }
        }
        
        // 寻找最近的敌人
        let mut nearest_enemy: Option<(Entity, f32)> = None;
        for (enemy_entity, enemy_transform, enemy_health) in all_players.iter() {
            if enemy_entity == ai_entity || enemy_health.current <= 0 {
                continue;
            }
            
            let enemy_pos = enemy_transform.translation.truncate();
            let distance = ai_pos.distance(enemy_pos);
            
            if nearest_enemy.is_none() || distance < nearest_enemy.unwrap().1 {
                nearest_enemy = Some((enemy_entity, distance));
            }
        }
        
        // 寻找道具
        let mut nearest_powerup: Option<(Vec2, f32)> = None;
        for (powerup_transform, powerup) in powerups.iter() {
            let powerup_pos = powerup_transform.translation.truncate();
            let distance = ai_pos.distance(powerup_pos);
            
            if nearest_powerup.is_none() || distance < nearest_powerup.unwrap().1 {
                nearest_powerup = Some((powerup_pos, distance));
            }
        }
        
        // 决策逻辑
        ai.state = if let Some((_, threat_distance, _)) = nearest_threat {
            if threat_distance < 60.0 {
                AIState::Dodging
            } else if let Some((enemy, distance)) = nearest_enemy {
                ai.target = Some(enemy);
                if distance < 300.0 && current_time - ai.last_attack_time > 1.0 {
                    AIState::Attacking
                } else {
                    AIState::Chasing
                }
            } else {
                AIState::Idle
            }
        } else if ai_health.current == 1 && nearest_powerup.is_some() {
            AIState::Collecting
        } else if let Some((enemy, distance)) = nearest_enemy {
            ai.target = Some(enemy);
            if distance < 300.0 && current_time - ai.last_attack_time > 1.0 {
                AIState::Attacking
            } else {
                AIState::Chasing
            }
        } else {
            AIState::Idle
        };
    }
}

// AI行为执行
fn ai_behavior_system(
    mut ai_controllers: Query<(
        &mut AIController,
        &mut Velocity,
        &Transform,
        &Player,
    )>,
    targets: Query<&Transform, With<Player>>,
    mut throw_events: EventWriter<ThrowBoomerangEvent>,
    time: Res<Time>,
) {
    for (mut ai, mut velocity, transform, player) in ai_controllers.iter_mut() {
        let ai_pos = transform.translation.truncate();
        
        match ai.state {
            AIState::Idle => {
                // 随机巡逻
                if rand::random::<f32>() < 0.01 {
                    velocity.0 = Vec2::new(
                        rand::random::<f32>() * 2.0 - 1.0,
                        rand::random::<f32>() * 2.0 - 1.0,
                    ).normalize() * 100.0;
                }
            }
            
            AIState::Chasing => {
                if let Some(target_entity) = ai.target {
                    if let Ok(target_transform) = targets.get(target_entity) {
                        let target_pos = target_transform.translation.truncate();
                        let direction = (target_pos - ai_pos).normalize();
                        
                        // 添加一些随机性，让AI不那么完美
                        let randomness = match ai.skill_level {
                            SkillLevel::Easy => 0.3,
                            SkillLevel::Medium => 0.15,
                            SkillLevel::Hard => 0.05,
                        };
                        
                        let random_offset = Vec2::new(
                            (rand::random::<f32>() - 0.5) * randomness,
                            (rand::random::<f32>() - 0.5) * randomness,
                        );
                        
                        velocity.0 = (direction + random_offset).normalize() * player.move_speed;
                    }
                }
            }
            
            AIState::Attacking => {
                if let Some(target_entity) = ai.target {
                    if let Ok(target_transform) = targets.get(target_entity) {
                        let target_pos = target_transform.translation.truncate();
                        let direction = (target_pos - ai_pos).normalize();
                        
                        // 预测目标位置
                        let prediction_time = match ai.skill_level {
                            SkillLevel::Easy => 0.0,    // 不预测
                            SkillLevel::Medium => 0.2,  // 轻微预测
                            SkillLevel::Hard => 0.4,    // 准确预测
                        };
                        
                        // 投掷回旋镖
                        throw_events.send(ThrowBoomerangEvent {
                            player_entity: player.entity,
                            direction,
                            power: 1.0,
                        });
                        
                        ai.last_attack_time = time.elapsed_secs();
                        ai.state = AIState::Chasing;
                    }
                }
            }
            
            AIState::Dodging => {
                // 躲避逻辑 - 垂直于威胁方向移动
                if let Some(threat_direction) = calculate_threat_direction(&ai_pos, &boomerangs) {
                    let dodge_direction = Vec2::new(-threat_direction.y, threat_direction.x);
                    velocity.0 = dodge_direction * player.move_speed * 1.5;
                }
            }
            
            AIState::Collecting => {
                // 收集道具逻辑
                if let Some(powerup_pos) = find_nearest_powerup(&ai_pos, &powerups) {
                    let direction = (powerup_pos - ai_pos).normalize();
                    velocity.0 = direction * player.move_speed;
                }
            }
            
            AIState::Fleeing => {
                // 逃跑逻辑 - 远离所有敌人
                if let Some(flee_direction) = calculate_flee_direction(&ai_pos, &all_players) {
                    velocity.0 = flee_direction * player.move_speed * 1.2;
                }
            }
        }
    }
}

// 路径查找系统（简化版）
fn find_path(start: Vec2, goal: Vec2, obstacles: &[Vec2]) -> Vec<Vec2> {
    // 简单的直线路径，绕过障碍物
    let mut path = vec![start];
    
    let direct = goal - start;
    let distance = direct.length();
    let direction = direct.normalize();
    
    // 检查直线路径是否被阻挡
    let mut blocked = false;
    for obstacle in obstacles {
        let to_obstacle = *obstacle - start;
        let projection = to_obstacle.dot(direction);
        
        if projection > 0.0 && projection < distance {
            let closest_point = start + direction * projection;
            if closest_point.distance(*obstacle) < 30.0 {
                blocked = true;
                break;
            }
        }
    }
    
    if blocked {
        // 添加绕行点
        let perpendicular = Vec2::new(-direction.y, direction.x);
        let midpoint = start + direct * 0.5;
        path.push(midpoint + perpendicular * 100.0);
    }
    
    path.push(goal);
    path
}
```

---

## 10. 多人游戏架构

### 10.1 本地多人实现

```rust
// 玩家管理
#[derive(Resource)]
pub struct PlayerManager {
    pub players: Vec<PlayerInfo>,
    pub max_players: usize,
    pub input_devices: HashMap<u8, InputDevice>,
}

#[derive(Clone)]
pub struct PlayerInfo {
    pub id: u8,
    pub name: String,
    pub character: CharacterType,
    pub color: Color,
    pub ready: bool,
    pub score: i32,
    pub wins: i32,
}

#[derive(Clone)]
pub enum InputDevice {
    Keyboard(PlayerControls),
    Gamepad(GamepadId),
}

// 玩家加入系统
fn handle_player_join(
    mut player_manager: ResMut<PlayerManager>,
    keyboard: Res<ButtonInput<KeyCode>>,
    gamepads: Res<Gamepads>,
    buttons: Res<ButtonInput<GamepadButton>>,
) {
    // 检查键盘玩家1
    if keyboard.just_pressed(KeyCode::Space) {
        if !player_manager.has_player_with_device(InputDevice::Keyboard1) {
            player_manager.add_player(InputDevice::Keyboard1);
        }
    }
    
    // 检查键盘玩家2
    if keyboard.just_pressed(KeyCode::Enter) {
        if !player_manager.has_player_with_device(InputDevice::Keyboard2) {
            player_manager.add_player(InputDevice::Keyboard2);
        }
    }
    
    // 检查手柄
    for gamepad in gamepads.iter() {
        let button = GamepadButton::new(gamepad, GamepadButtonType::South);
        if buttons.just_pressed(button) {
            if !player_manager.has_player_with_device(InputDevice::Gamepad(gamepad)) {
                player_manager.add_player(InputDevice::Gamepad(gamepad));
            }
        }
    }
}

// 分屏相机系统
fn setup_split_screen(
    mut commands: Commands,
    player_manager: Res<PlayerManager>,
) {
    let player_count = player_manager.players.len();
    
    match player_count {
        1 => {
            // 单人全屏
            commands.spawn((
                Camera2d,
                Camera {
                    viewport: Some(Viewport {
                        physical_position: UVec2::new(0, 0),
                        physical_size: UVec2::new(1920, 1080),
                        ..default()
                    }),
                    ..default()
                },
                PlayerCamera { player_id: 0 },
            ));
        }
        2 => {
            // 双人上下分屏
            for i in 0..2 {
                commands.spawn((
                    Camera2d,
                    Camera {
                        viewport: Some(Viewport {
                            physical_position: UVec2::new(0, i * 540),
                            physical_size: UVec2::new(1920, 540),
                            ..default()
                        }),
                        ..default()
                    },
                    PlayerCamera { player_id: i as u8 },
                ));
            }
        }
        3..=4 => {
            // 四人四分屏
            for i in 0..player_count {
                let x = (i % 2) as u32 * 960;
                let y = (i / 2) as u32 * 540;
                
                commands.spawn((
                    Camera2d,
                    Camera {
                        viewport: Some(Viewport {
                            physical_position: UVec2::new(x, y),
                            physical_size: UVec2::new(960, 540),
                            ..default()
                        }),
                        ..default()
                    },
                    PlayerCamera { player_id: i as u8 },
                ));
            }
        }
        _ => {}
    }
}
```

### 10.2 网络多人架构（可选）

```rust
// 使用 bevy_renet 进行网络通信
use bevy_renet::*;

// 网络消息
#[derive(Debug, Serialize, Deserialize)]
pub enum NetworkMessage {
    PlayerInput {
        player_id: u8,
        movement: Vec2,
        actions: Vec<PlayerAction>,
    },
    GameState {
        tick: u32,
        players: Vec<PlayerState>,
        boomerangs: Vec<BoomerangState>,
    },
    PlayerJoined {
        player_id: u8,
        name: String,
    },
    PlayerLeft {
        player_id: u8,
    },
}

// 客户端预测
#[derive(Component)]
pub struct PredictedPosition {
    pub server_position: Vec2,
    pub client_position: Vec2,
    pub last_update_tick: u32,
}

// 延迟补偿
#[derive(Resource)]
pub struct NetworkTime {
    pub client_tick: u32,
    pub server_tick: u32,
    pub ping: f32,
    pub jitter: f32,
}

// 回滚系统
#[derive(Resource)]
pub struct RollbackManager {
    pub history: VecDeque<GameSnapshot>,
    pub max_history: usize,
}

#[derive(Clone)]
pub struct GameSnapshot {
    pub tick: u32,
    pub player_states: HashMap<u8, PlayerState>,
    pub boomerang_states: Vec<BoomerangState>,
}
```

---

## 11. 关卡设计系统

### 11.1 地图数据结构

```rust
// 地图定义
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MapData {
    pub name: String,
    pub size: (usize, usize),
    pub tiles: Vec<Vec<TileType>>,
    pub spawn_points: Vec<Vec2>,
    pub powerup_spawns: Vec<Vec2>,
    pub theme: MapTheme,
}

#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub enum TileType {
    Empty,
    Wall,
    DestructibleWall,
    Pit,
    Ice,
    Mud,
    Teleporter(usize), // 传送点ID
    PowerupSpawn,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum MapTheme {
    Arena,
    Forest,
    Ice,
    Lava,
    Space,
}

// 地图加载器
pub fn load_map(
    mut commands: Commands,
    asset_server: Res<AssetServer>,
    map_data: Res<MapData>,
    mut meshes: ResMut<Assets<Mesh>>,
    mut materials: ResMut<Assets<ColorMaterial>>,
) {
    let tile_size = 40.0;
    let offset = Vec2::new(
        -(map_data.size.0 as f32) * tile_size / 2.0,
        -(map_data.size.1 as f32) * tile_size / 2.0,
    );
    
    for (y, row) in map_data.tiles.iter().enumerate() {
        for (x, tile) in row.iter().enumerate() {
            let position = Vec2::new(
                x as f32 * tile_size + offset.x,
                y as f32 * tile_size + offset.y,
            );
            
            match tile {
                TileType::Wall => {
                    spawn_wall(&mut commands, position, tile_size, false);
                }
                TileType::DestructibleWall => {
                    spawn_wall(&mut commands, position, tile_size, true);
                }
                TileType::Ice => {
                    spawn_ice_tile(&mut commands, position, tile_size);
                }
                TileType::Pit => {
                    spawn_pit(&mut commands, position, tile_size);
                }
                _ => {}
            }
        }
    }
    
    // 生成出生点
    for (i, spawn_point) in map_data.spawn_points.iter().enumerate() {
        spawn_player_start(&mut commands, *spawn_point, i as u8);
    }
}
```

### 11.2 程序化地图生成

```rust
use rand::prelude::*;

pub fn generate_random_map(size: (usize, usize), seed: u64) -> MapData {
    let mut rng = StdRng::seed_from_u64(seed);
    let mut tiles = vec![vec![TileType::Empty; size.0]; size.1];
    
    // 生成外墙
    for x in 0..size.0 {
        tiles[0][x] = TileType::Wall;
        tiles[size.1 - 1][x] = TileType::Wall;
    }
    for y in 0..size.1 {
        tiles[y][0] = TileType::Wall;
        tiles[y][size.0 - 1] = TileType::Wall;
    }
    
    // 生成内部结构
    generate_maze(&mut tiles, &mut rng);
    
    // 添加特殊地形
    add_special_tiles(&mut tiles, &mut rng);
    
    // 生成出生点
    let spawn_points = generate_spawn_points(size, 4);
    
    // 生成道具点
    let powerup_spawns = generate_powerup_spawns(&tiles, 6, &mut rng);
    
    MapData {
        name: format!("Random_{}", seed),
        size,
        tiles,
        spawn_points,
        powerup_spawns,
        theme: MapTheme::Arena,
    }
}

fn generate_maze(tiles: &mut Vec<Vec<TileType>>, rng: &mut StdRng) {
    // 简单的随机墙体生成
    for y in (2..tiles.len() - 2).step_by(2) {
        for x in (2..tiles[0].len() - 2).step_by(2) {
            if rng.gen_bool(0.3) {
                tiles[y][x] = TileType::Wall;
                
                // 随机延伸墙体
                if rng.gen_bool(0.5) && x + 1 < tiles[0].len() - 1 {
                    tiles[y][x + 1] = TileType::Wall;
                }
                if rng.gen_bool(0.5) && y + 1 < tiles.len() - 1 {
                    tiles[y + 1][x] = TileType::Wall;
                }
            }
        }
    }
    
    // 添加一些可破坏墙体
    for y in 1..tiles.len() - 1 {
        for x in 1..tiles[0].len() - 1 {
            if tiles[y][x] == TileType::Empty && rng.gen_bool(0.1) {
                tiles[y][x] = TileType::DestructibleWall;
            }
        }
    }
}
```

---

## 12. UI与菜单系统

### 12.1 主菜单实现

```rust
use bevy_egui::{egui, EguiContext, EguiPlugin};

// UI状态
#[derive(Resource)]
pub struct UIState {
    pub current_menu: MenuType,
    pub selected_mode: GameMode,
    pub selected_map: usize,
    pub music_volume: f32,
    pub sfx_volume: f32,
}

#[derive(Clone, Copy, PartialEq)]
pub enum MenuType {
    Main,
    PlayMenu,
    Settings,
    Credits,
}

// 主菜单系统
fn main_menu_system(
    mut egui_context: Query<&mut EguiContext>,
    mut ui_state: ResMut<UIState>,
    mut next_state: ResMut<NextState<GameState>>,
) {
    let mut ctx = egui_context.single_mut();
    
    egui::CentralPanel::default().show(ctx.get_mut(), |ui| {
        ui.vertical_centered(|ui| {
            ui.add_space(100.0);
            
            // 游戏标题
            ui.heading(
                egui::RichText::new("回旋镖大战")
                    .size(60.0)
                    .color(egui::Color32::from_rgb(255, 200, 50))
            );
            
            ui.add_space(50.0);
            
            // 菜单按钮
            if ui.add_sized(
                [200.0, 50.0],
                egui::Button::new(
                    egui::RichText::new("开始游戏").size(24.0)
                )
            ).clicked() {
                ui_state.current_menu = MenuType::PlayMenu;
            }
            
            ui.add_space(10.0);
            
            if ui.add_sized(
                [200.0, 50.0],
                egui::Button::new(
                    egui::RichText::new("设置").size(24.0)
                )
            ).clicked() {
                ui_state.current_menu = MenuType::Settings;
            }
            
            ui.add_space(10.0);
            
            if ui.add_sized(
                [200.0, 50.0],
                egui::Button::new(
                    egui::RichText::new("退出").size(24.0)
                )
            ).clicked() {
                std::process::exit(0);
            }
        });
    });
}

// HUD系统
fn hud_system(
    mut commands: Commands,
    asset_server: Res<AssetServer>,
    players: Query<(&Player, &Health, &Transform)>,
    game_state: Res<MatchState>,
) {
    // 清理旧的HUD
    commands.entity(hud_entity).despawn_recursive();
    
    // 创建新的HUD
    commands
        .spawn((
            Node {
                width: Val::Percent(100.0),
                height: Val::Percent(100.0),
                ..default()
            },
            ..default()
        ))
        .with_children(|parent| {
            // 顶部计时器
            parent.spawn((
                Node {
                    position_type: PositionType::Absolute,
                    top: Val::Px(10.0),
                    width: Val::Percent(100.0),
                    justify_content: JustifyContent::Center,
                    ..default()
                },
                ..default()
            ))
            .with_children(|parent| {
                parent.spawn((
                    Text::new(format_time(game_state.time_remaining)),
                    TextFont {
                        font_size: 48.0,
                        ..default()
                    },
                    TextColor(Color::WHITE),
                ));
            });
            
            // 玩家状态栏
            for (i, (player, health, _)) in players.iter().enumerate() {
                let x_offset = 10.0 + (i as f32) * 200.0;
                
                parent.spawn((
                    Node {
                        position_type: PositionType::Absolute,
                        left: Val::Px(x_offset),
                        bottom: Val::Px(10.0),
                        width: Val::Px(180.0),
                        height: Val::Px(60.0),
                        padding: UiRect::all(Val::Px(5.0)),
                        ..default()
                    },
                    BackgroundColor(Color::srgba(0.0, 0.0, 0.0, 0.7)),
                    ..default()
                ))
                .with_children(|parent| {
                    // 玩家名称
                    parent.spawn((
                        Text::new(format!("P{}", player.id + 1)),
                        TextFont {
                            font_size: 20.0,
                            ..default()
                        },
                        TextColor(player_colors[player.id as usize]),
                    ));
                    
                    // 生命值显示
                    for j in 0..health.max {
                        let heart_color = if j < health.current {
                            Color::srgb(1.0, 0.0, 0.0)
                        } else {
                            Color::srgb(0.3, 0.3, 0.3)
                        };
                        
                        parent.spawn((
                            Node {
                                width: Val::Px(20.0),
                                height: Val::Px(20.0),
                                margin: UiRect::all(Val::Px(2.0)),
                                ..default()
                            },
                            BackgroundColor(heart_color),
                            ..default()
                        ));
                    }
                });
            }
        });
}
```

---

## 13. 优化与打磨

### 13.1 性能优化

```rust
// 性能监控
pub struct PerformancePlugin;

impl Plugin for PerformancePlugin {
    fn build(&self, app: &mut App) {
        app.add_plugins(FrameTimeDiagnosticsPlugin)
            .add_plugins(EntityCountDiagnosticsPlugin)
            .add_systems(Update, performance_monitor);
    }
}

fn performance_monitor(
    diagnostics: Res<DiagnosticsStore>,
    mut last_report: Local<f32>,
    time: Res<Time>,
) {
    if time.elapsed_secs() - *last_report > 1.0 {
        if let Some(fps) = diagnostics.get(&FrameTimeDiagnosticsPlugin::FPS) {
            if let Some(value) = fps.smoothed() {
                if value < 55.0 {
                    warn!("Low FPS: {:.2}", value);
                }
            }
        }
        
        if let Some(entities) = diagnostics.get(&EntityCountDiagnosticsPlugin::ENTITY_COUNT) {
            if let Some(value) = entities.value() {
                if value > 10000.0 {
                    warn!("High entity count: {}", value);
                }
            }
        }
        
        *last_report = time.elapsed_secs();
    }
}

// 对象池
#[derive(Resource)]
pub struct ObjectPool<T: Component + Clone> {
    available: Vec<Entity>,
    prototype: T,
}

impl<T: Component + Clone> ObjectPool<T> {
    pub fn spawn(&mut self, commands: &mut Commands) -> Entity {
        if let Some(entity) = self.available.pop() {
            // 重用现有实体
            commands.entity(entity).insert(Visibility::Visible);
            entity
        } else {
            // 创建新实体
            commands.spawn(self.prototype.clone()).id()
        }
    }
    
    pub fn despawn(&mut self, entity: Entity, commands: &mut Commands) {
        commands.entity(entity).insert(Visibility::Hidden);
        self.available.push(entity);
    }
}
```

### 13.2 游戏感优化

```rust
// 屏幕震动
#[derive(Resource)]
pub struct ScreenShake {
    pub intensity: f32,
    pub duration: f32,
    pub elapsed: f32,
}

fn screen_shake_system(
    mut shake: ResMut<ScreenShake>,
    mut camera: Query<&mut Transform, With<Camera2d>>,
    time: Res<Time>,
) {
    if shake.elapsed < shake.duration {
        shake.elapsed += time.delta_secs();
        
        let progress = shake.elapsed / shake.duration;
        let current_intensity = shake.intensity * (1.0 - progress);
        
        for mut transform in camera.iter_mut() {
            let offset = Vec2::new(
                (rand::random::<f32>() - 0.5) * current_intensity,
                (rand::random::<f32>() - 0.5) * current_intensity,
            );
            
            transform.translation.x = offset.x;
            transform.translation.y = offset.y;
        }
    } else {
        // 重置相机位置
        for mut transform in camera.iter_mut() {
            transform.translation.x = 0.0;
            transform.translation.y = 0.0;
        }
    }
}

// 粒子效果
fn spawn_hit_particles(
    mut commands: Commands,
    position: Vec2,
    color: Color,
) {
    for _ in 0..10 {
        let velocity = Vec2::new(
            (rand::random::<f32>() - 0.5) * 200.0,
            (rand::random::<f32>() - 0.5) * 200.0,
        );
        
        commands.spawn((
            Particle {
                velocity,
                lifetime: 0.5,
                size: 5.0,
                color,
            },
            Transform::from_translation(position.extend(5.0)),
            Sprite {
                color,
                custom_size: Some(Vec2::splat(5.0)),
                ..default()
            },
        ));
    }
}

// 时间慢放
#[derive(Resource)]
pub struct TimeScale(pub f32);

fn apply_time_scale(
    time_scale: Res<TimeScale>,
    mut time: ResMut<Time<Virtual>>,
) {
    time.set_relative_speed(time_scale.0);
}
```

---

## 14. 测试与迭代

### 14.1 测试计划

#### 功能测试清单

| 测试项 | 优先级 | 测试方法 | 通过标准 |
|-------|--------|---------|---------|
| 移动控制 | 高 | 手动测试8方向 | 响应及时，无卡顿 |
| 回旋镖投掷 | 高 | 各角度投掷 | 轨迹正确，能返回 |
| 碰撞检测 | 高 | 边界测试 | 无穿墙，判定准确 |
| 伤害系统 | 高 | 击中测试 | 扣血正确，有无敌时间 |
| AI行为 | 中 | 观察AI | 行为合理，难度适中 |
| 道具系统 | 中 | 逐个测试 | 效果正确，无bug |
| UI响应 | 中 | 点击测试 | 响应快，无错位 |
| 音效播放 | 低 | 触发测试 | 时机正确，无延迟 |
| 性能 | 高 | 压力测试 | 保持60FPS |

### 14.2 平衡性调整

```rust
// 配置文件方式
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BalanceConfig {
    pub player_speed: f32,
    pub boomerang_speed: f32,
    pub boomerang_damage: i32,
    pub powerup_duration: f32,
    pub ai_reaction_time: f32,
    pub respawn_time: f32,
}

impl Default for BalanceConfig {
    fn default() -> Self {
        Self {
            player_speed: 200.0,
            boomerang_speed: 600.0,
            boomerang_damage: 1,
            powerup_duration: 15.0,
            ai_reaction_time: 0.3,
            respawn_time: 3.0,
        }
    }
}

// 热重载配置
fn reload_balance_config(
    mut config: ResMut<BalanceConfig>,
    keyboard: Res<ButtonInput<KeyCode>>,
) {
    if keyboard.just_pressed(KeyCode::F5) {
        if let Ok(contents) = std::fs::read_to_string("balance.json") {
            if let Ok(new_config) = serde_json::from_str::<BalanceConfig>(&contents) {
                *config = new_config;
                info!("Balance config reloaded");
            }
        }
    }
}
```

### 14.3 玩家反馈收集

建立反馈机制：
1. **内置反馈表单**
2. **自动崩溃报告**
3. **游戏内录像功能**
4. **Steam创意工坊（如果发布）**

---

## 15. 发布与运营

### 15.1 构建与打包

```bash
# Windows构建
cargo build --release --target x86_64-pc-windows-msvc

# Mac构建
cargo build --release --target x86_64-apple-darwin
cargo build --release --target aarch64-apple-darwin

# Linux构建
cargo build --release --target x86_64-unknown-linux-gnu

# Web构建（WASM）
cargo install wasm-bindgen-cli
cargo build --release --target wasm32-unknown-unknown
wasm-bindgen --out-dir ./out/ --target web ./target/wasm32-unknown-unknown/release/boomerang_battle.wasm
```

### 15.2 发布平台选择

| 平台 | 优势 | 劣势 | 建议 |
|-----|------|------|------|
| **itch.io** | 免费，独立友好 | 用户基数小 | ✅ 首选 |
| **Steam** | 用户多，收入高 | $100费用 | 第二步 |
| **Epic** | 分成低 | 审核严格 | 可选 |
| **自建网站** | 完全控制 | 流量难获取 | 补充 |

### 15.3 营销策略

#### 免费营销渠道
1. **社交媒体**
   - Twitter/X: #gamedev #indiedev
   - Reddit: r/IndieGaming, r/rust_gamedev
   - Discord: 游戏开发社区

2. **视频平台**
   - YouTube: 开发日志
   - Twitch: 开发直播
   - B站: 中文社区

3. **游戏媒体**
   - IndieDB
   - GameJolt
   - TIGSource

### 15.4 后续更新计划

```
v1.1 - 内容更新
- 新增4张地图
- 新增3种道具
- 改进AI

v1.2 - 多人更新
- 在线对战
- 排行榜
- 自定义房间

v1.3 - 创意工坊
- 地图编辑器
- 角色皮肤
- 模组支持

v2.0 - 大型更新
- 故事模式
- 新游戏模式
- 成就系统
```

---

## 实战代码示例：第一周原型

```rust
// main.rs - 最小可玩原型
use bevy::prelude::*;

fn main() {
    App::new()
        .add_plugins(DefaultPlugins)
        .add_systems(Startup, setup)
        .add_systems(Update, (
            player_movement,
            boomerang_throw,
            boomerang_update,
            check_collisions,
        ))
        .run();
}

#[derive(Component)]
struct Player {
    id: u8,
    speed: f32,
}

#[derive(Component)]
struct Boomerang {
    owner: Entity,
    velocity: Vec2,
    returning: bool,
}

fn setup(mut commands: Commands) {
    // 相机
    commands.spawn(Camera2d::default());
    
    // 玩家1
    commands.spawn((
        Player { id: 0, speed: 200.0 },
        Sprite {
            color: Color::srgb(0.0, 0.5, 1.0),
            custom_size: Some(Vec2::splat(30.0)),
            ..default()
        },
        Transform::from_xyz(-100.0, 0.0, 0.0),
    ));
    
    // 玩家2
    commands.spawn((
        Player { id: 1, speed: 200.0 },
        Sprite {
            color: Color::srgb(1.0, 0.5, 0.0),
            custom_size: Some(Vec2::splat(30.0)),
            ..default()
        },
        Transform::from_xyz(100.0, 0.0, 0.0),
    ));
}

fn player_movement(
    keyboard: Res<ButtonInput<KeyCode>>,
    mut players: Query<(&Player, &mut Transform)>,
    time: Res<Time>,
) {
    for (player, mut transform) in players.iter_mut() {
        let mut direction = Vec2::ZERO;
        
        if player.id == 0 {
            // WASD控制
            if keyboard.pressed(KeyCode::KeyW) { direction.y += 1.0; }
            if keyboard.pressed(KeyCode::KeyS) { direction.y -= 1.0; }
            if keyboard.pressed(KeyCode::KeyA) { direction.x -= 1.0; }
            if keyboard.pressed(KeyCode::KeyD) { direction.x += 1.0; }
        } else {
            // 方向键控制
            if keyboard.pressed(KeyCode::ArrowUp) { direction.y += 1.0; }
            if keyboard.pressed(KeyCode::ArrowDown) { direction.y -= 1.0; }
            if keyboard.pressed(KeyCode::ArrowLeft) { direction.x -= 1.0; }
            if keyboard.pressed(KeyCode::ArrowRight) { direction.x += 1.0; }
        }
        
        if direction.length() > 0.0 {
            direction = direction.normalize();
            transform.translation += direction.extend(0.0) * player.speed * time.delta_secs();
        }
    }
}

fn boomerang_throw(
    mut commands: Commands,
    keyboard: Res<ButtonInput<KeyCode>>,
    players: Query<(Entity, &Player, &Transform)>,
) {
    for (entity, player, transform) in players.iter() {
        let should_throw = if player.id == 0 {
            keyboard.just_pressed(KeyCode::Space)
        } else {
            keyboard.just_pressed(KeyCode::Enter)
        };
        
        if should_throw {
            commands.spawn((
                Boomerang {
                    owner: entity,
                    velocity: Vec2::new(500.0, 0.0), // 简化：固定方向
                    returning: false,
                },
                Sprite {
                    color: Color::srgb(1.0, 1.0, 0.0),
                    custom_size: Some(Vec2::splat(15.0)),
                    ..default()
                },
                Transform::from_translation(transform.translation),
            ));
        }
    }
}

fn boomerang_update(
    mut boomerangs: Query<(&mut Boomerang, &mut Transform), Without<Player>>,
    players: Query<&Transform, With<Player>>,
    time: Res<Time>,
    mut commands: Commands,
) {
    for (mut boomerang, mut transform) in boomerangs.iter_mut() {
        // 移动回旋镖
        transform.translation += boomerang.velocity.extend(0.0) * time.delta_secs();
        
        // 简单的返回逻辑
        if transform.translation.length() > 300.0 && !boomerang.returning {
            boomerang.returning = true;
            boomerang.velocity = -boomerang.velocity;
        }
        
        // 检查是否回到主人身边
        if boomerang.returning {
            if let Ok(owner_transform) = players.get(boomerang.owner) {
                let distance = transform.translation.distance(owner_transform.translation);
                if distance < 20.0 {
                    // 回收回旋镖
                    commands.entity(entity).despawn();
                }
            }
        }
    }
}

fn check_collisions(
    boomerangs: Query<(&Boomerang, &Transform)>,
    mut players: Query<(Entity, &Transform), With<Player>>,
) {
    for (boomerang, boom_transform) in boomerangs.iter() {
        for (player_entity, player_transform) in players.iter_mut() {
            if player_entity == boomerang.owner {
                continue;
            }
            
            let distance = boom_transform.translation.distance(player_transform.translation);
            if distance < 25.0 {
                println!("玩家被击中！");
                // TODO: 实现伤害系统
            }
        }
    }
}
```

---

## 总结与鼓励

### 你已经拥有的
1. **完整的开发路线图**：从原型到发布的每一步
2. **技术实现细节**：核心系统的代码示例
3. **项目管理方法**：时间规划和风险管理
4. **资源获取渠道**：美术、音效的免费来源
5. **优化和迭代策略**：让游戏越来越好

### 成功的关键
1. **保持简单**：先做出能玩的，再逐步完善
2. **快速迭代**：每天都要有可见的进展
3. **寻求反馈**：让朋友试玩，听取意见
4. **坚持到底**：遇到困难是正常的，解决它
5. **享受过程**：做游戏本身就是乐趣

### 第一步行动
```bash
# 立即开始！
mkdir boomerang-battle
cd boomerang-battle
cargo init
# 复制上面的原型代码到 main.rs
cargo add bevy
cargo run
```

### 每日检查清单
- [ ] 今天写了代码吗？
- [ ] 解决了什么问题？
- [ ] 学到了什么新东西？
- [ ] 明天的目标是什么？
- [ ] 需要什么帮助？

### 激励语录

> "完成比完美更重要。" - Done is better than perfect.

> "每个伟大的游戏都始于一个简单的原型。"

> "坚持100天，你会惊讶于自己能做到什么。"

### 社区支持
- Bevy Discord: https://discord.gg/bevy
- Rust GameDev: https://github.com/rust-gamedev
- Reddit: r/rust_gamedev
- 中文社区：Rust语言中文社区

### 最后的话

做游戏是一段奇妙的旅程。你会遇到bug，会重写代码，会怀疑自己，但当你看到角色在屏幕上动起来，当朋友玩你的游戏露出笑容，当陌生人给你好评时，一切都值得了。

**现在，关闭这个文档，打开你的代码编辑器，开始创造属于你的回旋镖传奇吧！**

---

*愿回旋镖与你同在！* 🪃✨