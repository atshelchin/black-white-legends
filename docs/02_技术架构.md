# 02 技术架构

## Bevy 引擎基础

### 什么是 Bevy？
Bevy 是一个用 Rust 编写的现代游戏引擎，采用 ECS（Entity Component System）架构。它具有以下特点：
- **数据驱动**：通过组合组件来构建游戏对象
- **并行化**：自动并行执行系统，充分利用多核 CPU
- **模块化**：通过插件系统组织代码

### ECS 架构解释
```rust
// Entity（实体）：一个唯一的 ID，代表游戏中的一个对象
// Component（组件）：附加到实体上的数据
#[derive(Component)]
struct GoBoard;  // 标记这是一个棋盘

// System（系统）：处理组件的逻辑
fn draw_board_system(
    query: Query<&Transform, With<GoBoard>>  // 查询所有带 GoBoard 组件的实体
) {
    // 处理逻辑
}
```

## 模块化设计

### 核心模块：go_board.rs

#### 1. 配置结构体
```rust
pub struct GoBoardConfig {
    pub board_size: BoardSize,        // 棋盘规格
    pub show_coordinates: bool,        // 是否显示坐标
    pub board_color: Color,           // 棋盘颜色
    // ... 其他配置
}
```

#### 2. 组件定义
```rust
#[derive(Component)]
pub struct GoBoard;        // 棋盘背景
#[derive(Component)]
pub struct BoardLine;      // 棋盘线
#[derive(Component)]
pub struct StarPoint;      // 星位点
#[derive(Component)]
pub struct CoordinateLabel; // 坐标标注
```

#### 3. 事件系统
```rust
#[derive(Event)]
pub struct RedrawBoardEvent;  // 重绘事件

#[derive(Event)]
pub struct UpdateBoardConfigEvent {
    pub config: GoBoardConfig,  // 配置更新事件
}
```

### 插件架构
```rust
pub struct GoBoardPlugin {
    pub initial_config: GoBoardConfig,
}

impl Plugin for GoBoardPlugin {
    fn build(&self, app: &mut App) {
        app.insert_resource(CurrentGoBoardConfig(self.initial_config.clone()))
            .add_event::<RedrawBoardEvent>()
            .add_event::<UpdateBoardConfigEvent>()
            .add_systems(Update, (
                handle_config_update,
                handle_board_redraw,
            ).chain());
    }
}
```

## 渲染技术

### 2D 图形绘制
```rust
// 使用 Bevy 的 2D 网格系统
commands.spawn((
    Mesh2d(meshes.add(Rectangle::new(width, height))),  // 矩形网格
    MeshMaterial2d(materials.add(color)),               // 材质颜色
    Transform::from_translation(Vec3::new(x, y, z)),    // 位置，z 控制层级
));
```

### 坐标系统
- **原点**：屏幕中心 (0, 0)
- **X 轴**：向右为正
- **Y 轴**：向上为正
- **Z 轴**：控制绘制顺序（层级）

### 层级管理
```rust
// Z 坐标决定绘制顺序
0.0  // 棋盘背景
1.0  // 棋盘线
2.0  // 星位点
3.0  // 坐标标注
```

## 响应式设计实现

### 窗口大小适配
```rust
fn calculate_cell_size(window_size: f32, board_size: i32) -> f32 {
    let padding = if window_size > 1400.0 { 50.0 } else { 100.0 };
    let available_space = window_size - padding;
    available_space / (board_size as f32 + 1.0)
}
```

### 窗口调整事件处理
```rust
fn handle_window_resize(
    mut resize_events: EventReader<WindowResized>,
    mut redraw_events: EventWriter<RedrawBoardEvent>,
) {
    if !resize_events.is_empty() {
        resize_events.clear();
        redraw_events.send(RedrawBoardEvent);  // 触发重绘
    }
}
```

## 性能优化策略

### 1. 事件批处理
```rust
// 清空所有事件，避免重复处理
resize_events.clear();
```

### 2. 条件重绘
```rust
// 仅在配置变化时重绘
if board_size.is_changed() || show_coords.is_changed() {
    // 重绘逻辑
}
```

### 3. 实体复用
```rust
// 先清除旧实体
for entity in board_entities.iter() {
    commands.entity(entity).despawn();
}
// 再创建新实体
```

## 事件流程图

```
用户输入 → 键盘事件处理 → 发送配置更新事件
                ↓
        配置更新系统处理
                ↓
        发送重绘事件
                ↓
        重绘系统处理
                ↓
        清除旧实体 → 创建新实体
```

## 关键设计决策

### 1. 为什么使用 ECS？
- **灵活性**：组件可以自由组合
- **性能**：系统可以并行执行
- **可维护性**：逻辑清晰分离

### 2. 为什么使用事件系统？
- **解耦**：输入处理与渲染分离
- **可扩展**：容易添加新的事件处理
- **可测试**：可以模拟事件进行测试

### 3. 为什么固定棋盘背景大小？
- **视觉稳定**：切换棋盘规格时不会突变
- **用户体验**：符合直觉的缩放行为
- **性能优化**：减少不必要的重新计算

## 代码组织最佳实践

### 1. 单一职责
每个系统只负责一个功能：
- `handle_keyboard_input`：处理键盘输入
- `handle_window_resize`：处理窗口调整
- `draw_board`：绘制棋盘

### 2. 配置与逻辑分离
- 配置通过 `GoBoardConfig` 管理
- 逻辑通过系统函数实现
- 通过资源和事件连接

### 3. 公共 API 设计
```rust
// 对外暴露的简单接口
pub struct GoBoardPlugin;
pub struct GoBoardConfig;
pub enum BoardSize;

// 内部实现细节隐藏
fn draw_coordinates(...) { /* 私有实现 */ }
```

## 扩展性考虑

### 添加新功能的步骤
1. 定义新组件（如果需要）
2. 创建新事件（如果需要）
3. 实现处理系统
4. 在插件中注册系统

### 示例：添加落子功能
```rust
// 1. 定义组件
#[derive(Component)]
struct Stone {
    color: StoneColor,
    position: (i32, i32),
}

// 2. 定义事件
#[derive(Event)]
struct PlaceStoneEvent {
    position: (i32, i32),
    color: StoneColor,
}

// 3. 实现系统
fn handle_place_stone(
    mut events: EventReader<PlaceStoneEvent>,
    mut commands: Commands,
) {
    for event in events.read() {
        // 创建棋子实体
    }
}

// 4. 注册到插件
app.add_systems(Update, handle_place_stone);
```