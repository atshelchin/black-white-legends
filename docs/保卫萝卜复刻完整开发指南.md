# 保卫萝卜复刻完整开发指南
*一个人，60天，从零到完整游戏的独立开发之路*

## 目录

### 第一部分：项目分析与规划
1. [游戏核心分析](#1-游戏核心分析)
2. [项目可行性评估](#2-项目可行性评估)
3. [开发时间规划](#3-开发时间规划)

### 第二部分：产品设计
4. [核心玩法设计](#4-核心玩法设计)
5. [关卡设计方法](#5-关卡设计方法)
6. [数值平衡系统](#6-数值平衡系统)

### 第三部分：技术实现
7. [技术架构设计](#7-技术架构设计)
8. [核心系统实现](#8-核心系统实现)
9. [性能优化策略](#9-性能优化策略)

### 第四部分：资源制作
10. [美术资源方案](#10-美术资源方案)
11. [音效音乐制作](#11-音效音乐制作)

### 第五部分：实战开发
12. [第一阶段：基础框架](#12-第一阶段基础框架)
13. [第二阶段：核心玩法](#13-第二阶段核心玩法)
14. [第三阶段：内容扩展](#14-第三阶段内容扩展)
15. [第四阶段：打磨优化](#15-第四阶段打磨优化)

---

## 第一部分：项目分析与规划

## 1. 游戏核心分析

### 1.1 保卫萝卜核心机制解构

#### 核心循环
```
放置防御塔 → 消灭敌人 → 获得金币 → 升级/建造更多塔 → 应对更强敌人
```

#### 核心乐趣点
1. **策略性**：塔的位置、类型选择
2. **成长感**：升级塔、解锁新塔
3. **收集欲**：全清障碍物、获得满星评价
4. **视觉反馈**：爆炸特效、金币飞舞

### 1.2 最小可行产品(MVP)定义

#### MVP必备功能（第一个月完成）
- [ ] 基础塔防机制（放塔、敌人路径、攻击）
- [ ] 3种基础防御塔
- [ ] 3种基础敌人
- [ ] 1个完整关卡
- [ ] 基础UI（生命值、金币、暂停）
- [ ] 简单的音效

#### 扩展功能（第二个月）
- [ ] 10个关卡
- [ ] 6种防御塔
- [ ] 8种敌人类型
- [ ] 障碍物系统
- [ ] 成就系统
- [ ] 关卡选择界面

### 1.3 技术难点预判

| 难点 | 难度 | 解决方案 | 预计时间 |
|------|------|----------|----------|
| 路径寻找系统 | ★★★ | 预定义路径点 | 3天 |
| 弹道计算 | ★★★★ | 抛物线+预判算法 | 5天 |
| 性能优化 | ★★★★★ | 对象池+批渲染 | 7天 |
| 数值平衡 | ★★★★ | Excel配表+快速迭代 | 持续调整 |
| 关卡编辑器 | ★★★ | 简化的可视化工具 | 5天 |

## 2. 项目可行性评估

### 2.1 个人能力评估表

制作这个自评表，诚实评估自己的能力：

```markdown
## 技能自评（1-5分）
- Rust编程： [  ] 分
- Bevy框架： [  ] 分
- 游戏设计： [  ] 分
- 2D美术：  [  ] 分
- 音效制作： [  ] 分
- 项目管理： [  ] 分

## 每日可投入时间
- 工作日： [  ] 小时
- 周末：   [  ] 小时

## 风险因素
- [ ] 是否有其他工作/学习任务
- [ ] 是否容易失去动力
- [ ] 是否有备用方案
```

### 2.2 资源获取方案

#### 美术资源（预算：$0-100）
1. **免费方案**
   - OpenGameArt.org（免费游戏美术）
   - Kenney.nl（高质量免费资源）
   - 自己用Aseprite画像素画（$20）

2. **低成本方案**
   - Unity Asset Store塔防包（$20-50）
   - Fiverr外包简单美术（$50-200）

#### 音效资源
1. **免费方案**
   - Freesound.org（音效库）
   - Bfxr（8位音效生成器）
   - YouTube Audio Library

2. **AI辅助方案**
   - Suno AI（音乐生成）
   - ElevenLabs（语音合成）

### 2.3 最坏情况应对

如果60天无法完成，底线方案：
1. **30天极简版**：1个关卡，2种塔，2种敌人
2. **开源发布**：邀请社区参与完善
3. **分章节发布**：每完成3个关卡发布一个版本

## 3. 开发时间规划

### 3.1 60天详细时间表

#### 第1-10天：基础搭建
```
Day 1-2:  项目初始化，基础场景搭建
Day 3-4:  网格系统，塔放置逻辑
Day 5-6:  敌人生成，路径移动
Day 7-8:  防御塔瞄准，攻击系统
Day 9-10: 基础UI，金币系统
```

#### 第11-20天：核心玩法
```
Day 11-12: 防御塔升级系统
Day 13-14: 多种敌人类型
Day 15-16: 波次管理系统
Day 17-18: 游戏状态管理（胜利/失败）
Day 19-20: 第一个完整关卡
```

#### 第21-30天：MVP完成
```
Day 21-22: 3种防御塔完整实现
Day 23-24: 音效系统集成
Day 25-26: 特效系统（爆炸、击中）
Day 27-28: 存档系统
Day 29-30: Bug修复，第一次测试
```

#### 第31-40天：内容扩展
```
Day 31-33: 关卡编辑器
Day 34-36: 5个新关卡
Day 37-38: 障碍物系统
Day 39-40: 更多敌人和塔类型
```

#### 第41-50天：系统完善
```
Day 41-42: 成就系统
Day 43-44: 关卡选择界面
Day 45-46: 暂停菜单，设置界面
Day 47-48: 性能优化
Day 49-50: 数值平衡调整
```

#### 第51-60天：打磨发布
```
Day 51-52: 最后5个关卡
Day 53-54: 全面测试
Day 55-56: Bug修复
Day 57-58: 发布准备（打包、文档）
Day 59-60: 发布和营销
```

### 3.2 每日工作模板

```markdown
## Day X 工作日志

### 今日目标（3个以内）
1. 实现XXX功能
2. 修复XXX问题
3. 优化XXX

### 实际完成
- [x] 完成了...
- [ ] 未完成...

### 遇到的问题
- 问题1：解决方案...

### 明日计划
- ...

### 时间记录
- 编程：2小时
- 美术：0.5小时
- 测试：0.5小时
```

---

## 第二部分：产品设计

## 4. 核心玩法设计

### 4.1 防御塔设计

#### 基础三塔设计
```rust
pub struct TowerData {
    pub name: String,
    pub cost: u32,
    pub damage: f32,
    pub range: f32,
    pub attack_speed: f32,
    pub special: TowerSpecial,
}

pub enum TowerSpecial {
    None,
    Slow(f32),        // 减速比例
    Splash(f32),      // 溅射范围
    Penetrate(u32),   // 穿透数量
}
```

| 塔类型 | 作用 | 成本 | 伤害 | 攻速 | 射程 | 特殊 |
|--------|------|------|------|------|------|------|
| 瓶子塔 | 单体输出 | 100 | 20 | 1.0 | 150 | 无 |
| 风扇塔 | 群体减速 | 120 | 10 | 0.8 | 120 | 减速30% |
| 太阳塔 | 范围伤害 | 160 | 30 | 0.5 | 100 | 溅射50 |

#### 升级系统设计
```
等级1 → 等级2 (花费150%)  → 等级3 (花费200%)
伤害:  100%  →  150%       →  220%
特殊:  100%  →  130%       →  170%
```

### 4.2 敌人设计

#### 敌人数据结构
```rust
pub struct EnemyData {
    pub name: String,
    pub health: f32,
    pub speed: f32,
    pub reward: u32,
    pub damage: u32,  // 对萝卜的伤害
    pub abilities: Vec<EnemyAbility>,
}

pub enum EnemyAbility {
    None,
    Fast,         // 高速移动
    Armored,      // 减伤
    Regenerate,   // 回血
    Split,        // 死亡分裂
}
```

#### 基础敌人设计
| 敌人 | 生命值 | 速度 | 奖励 | 特性 | 出现波次 |
|------|--------|------|------|------|----------|
| 小怪 | 50 | 100 | 10 | 无 | 1-20 |
| 速度怪 | 30 | 200 | 15 | 高速 | 3-20 |
| 装甲怪 | 150 | 80 | 25 | 减伤50% | 5-20 |
| 分裂怪 | 100 | 100 | 20 | 死亡分裂 | 8-20 |
| BOSS | 1000 | 60 | 100 | 多种能力 | 10,20 |

### 4.3 波次设计公式

```python
# 波次难度计算
def calculate_wave_difficulty(wave_number):
    base_difficulty = 100
    growth_rate = 1.15
    return base_difficulty * (growth_rate ** wave_number)

# 敌人数量
def enemy_count(wave):
    return min(5 + wave * 2, 30)

# 敌人间隔
def spawn_interval(wave):
    return max(0.5, 2.0 - wave * 0.05)
```

### 4.4 关卡设计原则

#### 关卡难度曲线
```
教学 → 熟悉 → 挑战 → 掌握 → 新机制 → 循环
 ↓      ↓      ↓      ↓       ↓
1-2    3-4    5-6    7-8     9-10
```

#### 关卡配置文件
```json
{
  "level_1": {
    "name": "新手村",
    "waves": 10,
    "starting_gold": 500,
    "lives": 20,
    "available_towers": ["bottle", "fan"],
    "path_layout": "simple_straight",
    "obstacles": [
      {"type": "box", "position": [5, 5], "reward": 20}
    ]
  }
}
```

## 5. 关卡设计方法

### 5.1 地图网格系统

#### 网格类型定义
```rust
pub enum TileType {
    Empty,        // 可建造
    Path,         // 敌人路径
    Spawn,        // 出生点
    Goal,         // 终点(萝卜位置)
    Obstacle,     // 障碍物
    Decoration,   // 装饰
}

pub struct MapGrid {
    pub width: usize,
    pub height: usize,
    pub tiles: Vec<Vec<TileType>>,
    pub path_points: Vec<Vec2>,  // 路径关键点
}
```

#### 地图编辑器简易实现
```rust
// 使用文本格式定义地图
const LEVEL_1: &str = "
    . . . . . . . . . .
    S = = = . . . . . .
    . . . = . . X . . .
    . . . = = = = . . .
    . . . . . . = . . .
    . . X . . . = . . .
    . . . . . . = = = G
    . . . . . . . . . .
";
// S=出生点 G=目标 ==路径 .=空地 X=障碍物
```

### 5.2 路径系统设计

#### 路径点方案
```rust
pub struct PathSystem {
    waypoints: Vec<Vec2>,
    total_length: f32,
}

impl PathSystem {
    pub fn get_position(&self, progress: f32) -> Vec2 {
        // 根据进度返回路径上的位置
        // 使用线性插值或贝塞尔曲线
    }
    
    pub fn get_direction(&self, progress: f32) -> Vec2 {
        // 返回当前朝向
    }
}
```

### 5.3 关卡进程设计

```rust
pub struct LevelProgress {
    pub current_wave: usize,
    pub total_waves: usize,
    pub enemies_spawned: usize,
    pub enemies_killed: usize,
    pub lives_remaining: u32,
    pub gold_earned: u32,
    pub obstacles_cleared: u32,
    pub towers_built: u32,
}

// 三星评价系统
pub fn calculate_stars(progress: &LevelProgress) -> u8 {
    let mut stars = 0;
    
    // 星1：通关
    if progress.lives_remaining > 0 {
        stars += 1;
    }
    
    // 星2：生命值超过50%
    if progress.lives_remaining >= 10 {
        stars += 1;
    }
    
    // 星3：清除所有障碍物
    if progress.obstacles_cleared == total_obstacles {
        stars += 1;
    }
    
    stars
}
```

## 6. 数值平衡系统

### 6.1 数值设计原则

#### DPS平衡公式
```
塔的DPS = 伤害 × 攻击频率
塔的价值 = DPS × 射程系数 × 特殊能力系数
成本 = 基础成本 × 价值系数
```

#### 经济系统平衡
```
每波金币收入 = 基础敌人奖励 × 敌人数量 + 波次奖励
预期塔数量 = 总金币收入 / 平均塔成本
难度系数 = 敌人总血量 / (预期塔数量 × 平均DPS × 波次时长)
```

### 6.2 数值配置表

使用CSV或JSON管理所有数值：

```csv
# towers.csv
id,name,cost,damage,range,speed,upgrade_cost,upgrade_damage
bottle_1,瓶子塔1级,100,20,150,1.0,150,30
bottle_2,瓶子塔2级,150,30,160,1.1,200,45
bottle_3,瓶子塔3级,200,45,170,1.2,0,0
```

### 6.3 快速平衡迭代

```rust
// 运行时可调整的数值系统
pub struct BalanceConfig {
    pub tower_damage_multiplier: f32,
    pub enemy_health_multiplier: f32,
    pub gold_multiplier: f32,
    pub wave_difficulty_curve: f32,
}

// 开发时使用控制台命令调整
impl BalanceConfig {
    pub fn apply_command(&mut self, cmd: &str) {
        // 例如: "balance tower_damage 1.2"
        // 实时调整数值，无需重新编译
    }
}
```

---

## 第三部分：技术实现

## 7. 技术架构设计

### 7.1 整体架构

```
┌─────────────────────────────────────┐
│          Game Manager               │
│  (状态管理、场景切换、存档)           │
└────────────┬────────────────────────┘
             │
    ┌────────┴────────┬───────────┬─────────┐
    ↓                 ↓           ↓         ↓
┌─────────┐    ┌──────────┐ ┌────────┐ ┌────────┐
│ Battle  │    │  Tower   │ │ Enemy  │ │  UI    │
│ System  │    │  System  │ │ System │ │ System │
└─────────┘    └──────────┘ └────────┘ └────────┘
    ↓                 ↓           ↓         ↓
┌──────────────────────────────────────────────┐
│              Resource Manager                │
│        (美术、音效、配置文件)                 │
└──────────────────────────────────────────────┘
```

### 7.2 ECS组件设计

```rust
// ===== 核心组件 =====
#[derive(Component)]
pub struct Tower {
    pub tower_type: TowerType,
    pub level: u32,
    pub damage: f32,
    pub range: f32,
    pub attack_cooldown: Timer,
}

#[derive(Component)]
pub struct Enemy {
    pub enemy_type: EnemyType,
    pub health: f32,
    pub max_health: f32,
    pub speed: f32,
    pub path_progress: f32,
    pub reward: u32,
}

#[derive(Component)]
pub struct Projectile {
    pub damage: f32,
    pub target: Entity,
    pub speed: f32,
    pub splash_radius: Option<f32>,
}

#[derive(Component)]
pub struct GridPosition {
    pub x: i32,
    pub y: i32,
}

// ===== 标记组件 =====
#[derive(Component)]
struct Selectable;

#[derive(Component)]
struct Hoverable;

#[derive(Component)]
struct Targetable;
```

### 7.3 系统设计

```rust
// 系统执行顺序很重要
app
    // 输入阶段
    .add_systems(PreUpdate, (
        mouse_input_system,
        keyboard_input_system,
    ))
    // 游戏逻辑
    .add_systems(Update, (
        wave_spawn_system,
        enemy_movement_system,
        tower_targeting_system,
        tower_shooting_system,
        projectile_movement_system,
        collision_detection_system,
        damage_system,
        death_system,
        resource_collection_system,
    ).chain())  // 使用chain保证顺序
    // 渲染更新
    .add_systems(PostUpdate, (
        health_bar_update_system,
        ui_update_system,
        animation_system,
    ));
```

## 8. 核心系统实现

### 8.1 网格放置系统

```rust
use bevy::prelude::*;

#[derive(Resource)]
pub struct GridMap {
    pub width: usize,
    pub height: usize,
    pub cell_size: f32,
    pub origin: Vec2,
    pub occupied: Vec<Vec<bool>>,
}

impl GridMap {
    pub fn world_to_grid(&self, world_pos: Vec2) -> Option<(usize, usize)> {
        let relative = world_pos - self.origin;
        let x = (relative.x / self.cell_size) as usize;
        let y = (relative.y / self.cell_size) as usize;
        
        if x < self.width && y < self.height {
            Some((x, y))
        } else {
            None
        }
    }
    
    pub fn grid_to_world(&self, x: usize, y: usize) -> Vec2 {
        Vec2::new(
            self.origin.x + x as f32 * self.cell_size + self.cell_size / 2.0,
            self.origin.y + y as f32 * self.cell_size + self.cell_size / 2.0,
        )
    }
    
    pub fn can_place(&self, x: usize, y: usize) -> bool {
        !self.occupied[y][x]
    }
}

// 放置塔的系统
fn tower_placement_system(
    mut commands: Commands,
    grid: Res<GridMap>,
    mouse: Res<ButtonInput<MouseButton>>,
    camera_query: Query<(&Camera, &GlobalTransform)>,
    windows: Query<&Window>,
    mut gold: ResMut<Gold>,
    selected_tower: Res<SelectedTowerType>,
) {
    if !mouse.just_pressed(MouseButton::Left) {
        return;
    }
    
    let (camera, camera_transform) = camera_query.single();
    let window = windows.single();
    
    if let Some(cursor_position) = window.cursor_position() {
        // 屏幕坐标转世界坐标
        let world_pos = camera.viewport_to_world_2d(
            camera_transform,
            cursor_position
        ).unwrap();
        
        // 世界坐标转网格坐标
        if let Some((x, y)) = grid.world_to_grid(world_pos) {
            if grid.can_place(x, y) && gold.0 >= selected_tower.cost {
                // 扣除金币
                gold.0 -= selected_tower.cost;
                
                // 生成塔
                let tower_pos = grid.grid_to_world(x, y);
                commands.spawn((
                    Tower {
                        tower_type: selected_tower.0.clone(),
                        level: 1,
                        damage: selected_tower.damage,
                        range: selected_tower.range,
                        attack_cooldown: Timer::from_seconds(1.0, TimerMode::Repeating),
                    },
                    GridPosition { x: x as i32, y: y as i32 },
                    Transform::from_translation(tower_pos.extend(1.0)),
                    // ... 其他组件
                ));
                
                // 标记网格已占用
                grid.occupied[y][x] = true;
            }
        }
    }
}
```

### 8.2 敌人路径系统

```rust
#[derive(Resource)]
pub struct PathManager {
    pub waypoints: Vec<Vec2>,
    pub total_length: f32,
    pub segment_lengths: Vec<f32>,
}

impl PathManager {
    pub fn new(waypoints: Vec<Vec2>) -> Self {
        let mut total_length = 0.0;
        let mut segment_lengths = Vec::new();
        
        for i in 1..waypoints.len() {
            let length = waypoints[i].distance(waypoints[i-1]);
            segment_lengths.push(length);
            total_length += length;
        }
        
        Self {
            waypoints,
            total_length,
            segment_lengths,
        }
    }
    
    pub fn get_position_at_progress(&self, progress: f32) -> (Vec2, Vec2) {
        let distance = progress * self.total_length;
        let mut accumulated = 0.0;
        
        for i in 0..self.segment_lengths.len() {
            let segment_length = self.segment_lengths[i];
            
            if accumulated + segment_length >= distance {
                let t = (distance - accumulated) / segment_length;
                let position = self.waypoints[i].lerp(self.waypoints[i + 1], t);
                let direction = (self.waypoints[i + 1] - self.waypoints[i]).normalize();
                return (position, direction);
            }
            
            accumulated += segment_length;
        }
        
        // 到达终点
        let last = self.waypoints.len() - 1;
        (self.waypoints[last], Vec2::ZERO)
    }
}

// 敌人移动系统
fn enemy_movement_system(
    mut enemy_query: Query<(&mut Enemy, &mut Transform)>,
    path: Res<PathManager>,
    time: Res<Time>,
    mut commands: Commands,
) {
    for (mut enemy, mut transform) in enemy_query.iter_mut() {
        // 更新进度
        enemy.path_progress += enemy.speed * time.delta_secs() / path.total_length;
        
        if enemy.path_progress >= 1.0 {
            // 到达终点，对基地造成伤害
            commands.entity(entity).despawn();
            // 触发伤害事件...
        } else {
            // 更新位置
            let (position, direction) = path.get_position_at_progress(enemy.path_progress);
            transform.translation = position.extend(0.5);
            
            // 更新朝向
            if direction != Vec2::ZERO {
                transform.rotation = Quat::from_rotation_z(direction.y.atan2(direction.x));
            }
        }
    }
}
```

### 8.3 防御塔系统

```rust
// 目标选择系统
fn tower_targeting_system(
    mut tower_query: Query<(&mut Tower, &Transform, &mut TargetEntity)>,
    enemy_query: Query<(Entity, &Transform), With<Enemy>>,
) {
    for (tower, tower_transform, mut target) in tower_query.iter_mut() {
        let tower_pos = tower_transform.translation.truncate();
        
        // 查找范围内的敌人
        let mut closest_enemy = None;
        let mut closest_distance = f32::MAX;
        
        for (enemy_entity, enemy_transform) in enemy_query.iter() {
            let enemy_pos = enemy_transform.translation.truncate();
            let distance = tower_pos.distance(enemy_pos);
            
            if distance <= tower.range && distance < closest_distance {
                closest_distance = distance;
                closest_enemy = Some(enemy_entity);
            }
        }
        
        target.0 = closest_enemy;
    }
}

// 攻击系统
fn tower_shooting_system(
    mut commands: Commands,
    mut tower_query: Query<(&mut Tower, &Transform, &TargetEntity)>,
    enemy_query: Query<&Transform>,
    time: Res<Time>,
    asset_server: Res<AssetServer>,
) {
    for (mut tower, tower_transform, target) in tower_query.iter_mut() {
        tower.attack_cooldown.tick(time.delta());
        
        if tower.attack_cooldown.just_finished() {
            if let Some(target_entity) = target.0 {
                if let Ok(enemy_transform) = enemy_query.get(target_entity) {
                    // 生成子弹
                    commands.spawn((
                        Projectile {
                            damage: tower.damage,
                            target: target_entity,
                            speed: 500.0,
                            splash_radius: None,
                        },
                        Transform::from_translation(tower_transform.translation),
                        // Sprite等其他组件...
                    ));
                    
                    // 播放音效
                    commands.spawn(AudioPlayer::new(asset_server.load("sounds/shoot.ogg")));
                }
            }
        }
    }
}

// 子弹移动系统
fn projectile_movement_system(
    mut commands: Commands,
    mut projectile_query: Query<(Entity, &mut Transform, &Projectile)>,
    enemy_query: Query<&Transform>,
    time: Res<Time>,
) {
    for (projectile_entity, mut projectile_transform, projectile) in projectile_query.iter_mut() {
        if let Ok(enemy_transform) = enemy_query.get(projectile.target) {
            let direction = (enemy_transform.translation - projectile_transform.translation).normalize();
            projectile_transform.translation += direction * projectile.speed * time.delta_secs();
            
            // 检查是否击中
            let distance = projectile_transform.translation.distance(enemy_transform.translation);
            if distance < 10.0 {
                // 触发伤害事件
                commands.entity(projectile.target).insert(DamageEvent {
                    damage: projectile.damage,
                });
                
                // 销毁子弹
                commands.entity(projectile_entity).despawn();
            }
        } else {
            // 目标已经不存在，销毁子弹
            commands.entity(projectile_entity).despawn();
        }
    }
}
```

### 8.4 波次管理系统

```rust
#[derive(Resource)]
pub struct WaveManager {
    pub current_wave: usize,
    pub total_waves: usize,
    pub enemies_to_spawn: Vec<EnemyType>,
    pub spawn_timer: Timer,
    pub wave_timer: Timer,
    pub state: WaveState,
}

#[derive(PartialEq)]
pub enum WaveState {
    Preparing,
    Spawning,
    Fighting,
    Completed,
}

fn wave_management_system(
    mut commands: Commands,
    mut wave_manager: ResMut<WaveManager>,
    time: Res<Time>,
    enemy_query: Query<Entity, With<Enemy>>,
    asset_server: Res<AssetServer>,
) {
    match wave_manager.state {
        WaveState::Preparing => {
            wave_manager.wave_timer.tick(time.delta());
            
            if wave_manager.wave_timer.just_finished() {
                // 准备下一波敌人
                wave_manager.enemies_to_spawn = generate_wave_enemies(wave_manager.current_wave);
                wave_manager.state = WaveState::Spawning;
            }
        }
        
        WaveState::Spawning => {
            wave_manager.spawn_timer.tick(time.delta());
            
            if wave_manager.spawn_timer.just_finished() && !wave_manager.enemies_to_spawn.is_empty() {
                // 生成一个敌人
                let enemy_type = wave_manager.enemies_to_spawn.pop().unwrap();
                spawn_enemy(&mut commands, enemy_type, &asset_server);
            }
            
            if wave_manager.enemies_to_spawn.is_empty() {
                wave_manager.state = WaveState::Fighting;
            }
        }
        
        WaveState::Fighting => {
            // 检查是否所有敌人都被消灭
            if enemy_query.is_empty() {
                wave_manager.current_wave += 1;
                
                if wave_manager.current_wave > wave_manager.total_waves {
                    wave_manager.state = WaveState::Completed;
                    // 触发胜利
                } else {
                    wave_manager.state = WaveState::Preparing;
                    wave_manager.wave_timer.reset();
                }
            }
        }
        
        WaveState::Completed => {
            // 关卡完成
        }
    }
}

fn generate_wave_enemies(wave: usize) -> Vec<EnemyType> {
    let mut enemies = Vec::new();
    
    // 基础敌人数量
    let basic_count = 5 + wave * 2;
    for _ in 0..basic_count {
        enemies.push(EnemyType::Basic);
    }
    
    // 从第3波开始出现快速敌人
    if wave >= 3 {
        let fast_count = wave - 2;
        for _ in 0..fast_count {
            enemies.push(EnemyType::Fast);
        }
    }
    
    // 从第5波开始出现装甲敌人
    if wave >= 5 {
        let armored_count = (wave - 4) / 2;
        for _ in 0..armored_count {
            enemies.push(EnemyType::Armored);
        }
    }
    
    // 每10波一个BOSS
    if wave % 10 == 0 {
        enemies.push(EnemyType::Boss);
    }
    
    enemies
}
```

## 9. 性能优化策略

### 9.1 对象池系统

```rust
#[derive(Resource)]
pub struct ProjectilePool {
    inactive: Vec<Entity>,
}

impl ProjectilePool {
    pub fn get(&mut self, commands: &mut Commands) -> Entity {
        if let Some(entity) = self.inactive.pop() {
            // 重用已存在的实体
            commands.entity(entity).insert(Active);
            entity
        } else {
            // 创建新实体
            commands.spawn(ProjectileBundle::default()).id()
        }
    }
    
    pub fn return_to_pool(&mut self, entity: Entity, commands: &mut Commands) {
        commands.entity(entity)
            .remove::<Active>()
            .insert(Inactive);
        self.inactive.push(entity);
    }
}
```

### 9.2 批渲染优化

```rust
// 使用TextureAtlas批量渲染
fn setup_sprite_sheet(
    mut commands: Commands,
    asset_server: Res<AssetServer>,
    mut texture_atlases: ResMut<Assets<TextureAtlasLayout>>,
) {
    let texture = asset_server.load("sprites/enemies.png");
    let layout = TextureAtlasLayout::from_grid(
        UVec2::new(32, 32),
        8, 4,
        Some(UVec2::new(1, 1)),
        None
    );
    let layout_handle = texture_atlases.add(layout);
    
    // 所有敌人使用同一个texture atlas
    commands.insert_resource(EnemySpriteSheet {
        texture,
        layout: layout_handle,
    });
}
```

### 9.3 空间分区优化

```rust
// 使用网格空间分区加速碰撞检测
#[derive(Resource)]
pub struct SpatialGrid {
    cell_size: f32,
    cells: HashMap<(i32, i32), Vec<Entity>>,
}

impl SpatialGrid {
    pub fn update(&mut self, entity: Entity, position: Vec2) {
        let cell = self.position_to_cell(position);
        self.cells.entry(cell).or_insert_with(Vec::new).push(entity);
    }
    
    pub fn get_nearby_entities(&self, position: Vec2, radius: f32) -> Vec<Entity> {
        let mut entities = Vec::new();
        let cell_radius = (radius / self.cell_size).ceil() as i32;
        let center_cell = self.position_to_cell(position);
        
        for dx in -cell_radius..=cell_radius {
            for dy in -cell_radius..=cell_radius {
                let cell = (center_cell.0 + dx, center_cell.1 + dy);
                if let Some(cell_entities) = self.cells.get(&cell) {
                    entities.extend(cell_entities);
                }
            }
        }
        
        entities
    }
}
```

---

## 第四部分：资源制作

## 10. 美术资源方案

### 10.1 美术风格选择

#### 方案对比
| 风格 | 制作难度 | 所需时间 | 推荐工具 | 适合个人开发 |
|------|----------|----------|----------|--------------|
| 像素风格 | ★★ | 短 | Aseprite | ✅ 非常适合 |
| 矢量卡通 | ★★★ | 中 | Inkscape | ✅ 适合 |
| 手绘风格 | ★★★★ | 长 | Procreate | ❌ 不适合 |
| 3D渲染2D | ★★★★★ | 很长 | Blender | ❌ 不适合 |

#### 推荐：像素风格
- 制作效率高
- 修改方便
- 文件体积小
- 风格统一容易把控

### 10.2 必需美术资源清单

```markdown
## 精灵图 (Sprites)
### 防御塔 (每种3个等级)
- [ ] 瓶子塔 (16x16) x3
- [ ] 风扇塔 (16x16) x3
- [ ] 太阳塔 (16x16) x3

### 敌人 (4方向行走动画)
- [ ] 小怪 (16x16, 4帧) x4方向
- [ ] 快速怪 (16x16, 4帧) x4方向
- [ ] 装甲怪 (16x16, 4帧) x4方向
- [ ] BOSS (32x32, 4帧) x4方向

### 子弹/特效
- [ ] 普通子弹 (8x8)
- [ ] 爆炸特效 (32x32, 6帧)
- [ ] 击中特效 (16x16, 4帧)
- [ ] 金币 (8x8, 4帧)

### 地形
- [ ] 地面贴图 (16x16) x5种
- [ ] 路径贴图 (16x16) x9种(含转角)
- [ ] 装饰物 (16x16) x10种

### UI元素
- [ ] 按钮 (九宫格切片)
- [ ] 面板背景
- [ ] 图标集 (16x16) x20个
- [ ] 生命值条
- [ ] 字体(或使用系统字体)
```

### 10.3 快速制作流程

#### 使用Aseprite制作像素画
```bash
# 1. 创建模板
新建 16x16 画布
设置调色板（限制在16-32色）

# 2. 基础形状
画出轮廓 → 填充基础色 → 添加阴影 → 高光点缀

# 3. 动画制作
复制帧 → 微调 → 预览 → 导出

# 4. 批量导出
File → Export Sprite Sheet
设置: Columns=4, Rows=根据动画帧数
```

#### 颜色方案
```css
/* 推荐使用现成的像素画调色板 */
--background: #2C2C34;
--ground: #4B692F;
--path: #8B7355;
--enemy-red: #AC3232;
--tower-blue: #306082;
--gold: #F0E68C;
--ui-dark: #1A1A2E;
--ui-light: #EAEAEA;
```

### 10.4 免费资源获取

```markdown
## 免费资源网站
1. **OpenGameArt.org**
   - 搜索"tower defense"
   - 过滤License: CC0

2. **Kenney.nl**
   - Tower Defense Kit
   - UI Pack

3. **Itch.io**
   - 搜索"tower defense assets free"
   - 很多独立开发者的免费资源包

## AI辅助生成
1. **Midjourney/DALL-E**
   - Prompt: "pixel art tower defense game sprite sheet, 16x16"
   - 后期用Aseprite清理

2. **Stable Diffusion**
   - 使用pixel art专用模型
   - ControlNet控制构图
```

## 11. 音效音乐制作

### 11.1 音效需求清单

```markdown
## 必要音效
### 战斗音效
- [ ] 放置塔 (place.ogg)
- [ ] 升级塔 (upgrade.ogg)
- [ ] 瓶子塔攻击 (bottle_shoot.ogg)
- [ ] 风扇塔攻击 (fan_shoot.ogg)
- [ ] 太阳塔攻击 (sun_shoot.ogg)
- [ ] 敌人受击 (hit_1.ogg, hit_2.ogg)
- [ ] 敌人死亡 (death.ogg)
- [ ] 爆炸 (explosion.ogg)

### UI音效
- [ ] 按钮点击 (click.ogg)
- [ ] 按钮悬停 (hover.ogg)
- [ ] 金币获得 (coin.ogg)
- [ ] 波次开始 (wave_start.ogg)
- [ ] 胜利 (victory.ogg)
- [ ] 失败 (defeat.ogg)

## 背景音乐
- [ ] 主菜单 (menu.ogg)
- [ ] 战斗BGM (battle_1.ogg)
- [ ] 紧张BGM (battle_intense.ogg)
```

### 11.2 快速制作方案

#### 使用Bfxr生成8位音效
```python
# Bfxr参数预设
PRESETS = {
    "shoot": {
        "wave": "square",
        "frequency": 800,
        "slide": -0.3,
        "length": 0.1
    },
    "explosion": {
        "wave": "noise",
        "frequency": 200,
        "slide": -0.5,
        "length": 0.3
    },
    "coin": {
        "wave": "sine",
        "frequency": 1000,
        "arpeggio": 0.5,
        "length": 0.2
    }
}
```

#### 使用BeepBox制作简单BGM
```
1. 选择4/4拍，120BPM
2. 使用3-4个音轨
   - 主旋律(Lead)
   - 和弦(Chord)
   - 贝斯(Bass)
   - 鼓点(Drum)
3. 创建8-16小节循环
4. 导出为OGG格式
```

### 11.3 音频实现代码

```rust
use bevy::prelude::*;
use bevy::audio::{PlaybackSettings, Volume};

#[derive(Resource)]
pub struct AudioAssets {
    pub shoot: Handle<AudioSource>,
    pub hit: Handle<AudioSource>,
    pub coin: Handle<AudioSource>,
    pub bgm: Handle<AudioSource>,
}

// 音效管理器
#[derive(Resource)]
pub struct AudioManager {
    pub sfx_volume: f32,
    pub bgm_volume: f32,
    pub enabled: bool,
}

// 播放音效
fn play_sound_effect(
    commands: &mut Commands,
    audio_assets: &AudioAssets,
    audio_manager: &AudioManager,
    sound_type: SoundType,
) {
    if !audio_manager.enabled {
        return;
    }
    
    let (source, volume) = match sound_type {
        SoundType::Shoot => (&audio_assets.shoot, audio_manager.sfx_volume),
        SoundType::Hit => (&audio_assets.hit, audio_manager.sfx_volume * 0.7),
        SoundType::Coin => (&audio_assets.coin, audio_manager.sfx_volume * 0.8),
    };
    
    commands.spawn(
        AudioPlayer::new(source.clone()).with_settings(
            PlaybackSettings::DESPAWN.with_volume(Volume::new(volume))
        )
    );
}

// BGM控制
fn setup_bgm(
    mut commands: Commands,
    audio_assets: Res<AudioAssets>,
    audio_manager: Res<AudioManager>,
) {
    commands.spawn((
        AudioPlayer::new(audio_assets.bgm.clone()),
        PlaybackSettings::LOOP.with_volume(Volume::new(audio_manager.bgm_volume)),
    ));
}
```

---

## 第五部分：实战开发

## 12. 第一阶段：基础框架

### 12.1 项目初始化

```bash
# 创建项目
cargo new tower_defense_game
cd tower_defense_game

# 编辑Cargo.toml
```

```toml
[package]
name = "tower_defense_game"
version = "0.1.0"
edition = "2021"

[dependencies]
bevy = { version = "0.14", features = ["dynamic_linking"] }
bevy_asset_loader = "0.21"
bevy_kira_audio = "0.20"  # 更好的音频支持
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
rand = "0.8"

[profile.dev]
opt-level = 1  # 开发时的优化，提升性能

[profile.dev.package."*"]
opt-level = 3  # 依赖项最大优化

[profile.release]
lto = true
codegen-units = 1
```

### 12.2 基础架构代码

```rust
// main.rs
use bevy::prelude::*;

mod components;
mod systems;
mod resources;
mod states;
mod config;

use states::GameState;

fn main() {
    App::new()
        .add_plugins(DefaultPlugins.set(WindowPlugin {
            primary_window: Some(Window {
                title: "Tower Defense".to_string(),
                resolution: (1024.0, 768.0).into(),
                ..default()
            }),
            ..default()
        }))
        .init_state::<GameState>()
        .add_systems(Startup, setup)
        .add_plugins(GamePlugin)
        .run();
}

pub struct GamePlugin;

impl Plugin for GamePlugin {
    fn build(&self, app: &mut App) {
        app
            // 资源
            .init_resource::<Gold>()
            .init_resource::<Lives>()
            .init_resource::<WaveManager>()
            .init_resource::<GridMap>()
            
            // 游戏状态系统
            .add_systems(OnEnter(GameState::Menu), setup_menu)
            .add_systems(Update, menu_system.run_if(in_state(GameState::Menu)))
            .add_systems(OnExit(GameState::Menu), cleanup_menu)
            
            .add_systems(OnEnter(GameState::Playing), setup_game)
            .add_systems(Update, (
                input_system,
                wave_system,
                enemy_movement_system,
                tower_system,
                projectile_system,
                collision_system,
                ui_update_system,
            ).run_if(in_state(GameState::Playing)))
            
            .add_systems(OnEnter(GameState::Paused), pause_game)
            .add_systems(Update, pause_menu_system.run_if(in_state(GameState::Paused)))
            
            .add_systems(OnEnter(GameState::GameOver), show_game_over)
            .add_systems(Update, game_over_system.run_if(in_state(GameState::GameOver)));
    }
}

fn setup(mut commands: Commands) {
    // 2D相机
    commands.spawn(Camera2d);
}
```

### 12.3 游戏状态管理

```rust
// states.rs
use bevy::prelude::*;

#[derive(States, Default, Clone, Eq, PartialEq, Debug, Hash)]
pub enum GameState {
    #[default]
    Menu,
    Playing,
    Paused,
    GameOver,
    Victory,
}

#[derive(States, Default, Clone, Eq, PartialEq, Debug, Hash)]
pub enum PlayingState {
    #[default]
    Preparing,
    Building,
    WaveInProgress,
    WaveComplete,
}

// 状态转换系统
pub fn game_state_transition_system(
    keyboard_input: Res<ButtonInput<KeyCode>>,
    current_state: Res<State<GameState>>,
    mut next_state: ResMut<NextState<GameState>>,
) {
    match current_state.get() {
        GameState::Playing => {
            if keyboard_input.just_pressed(KeyCode::Escape) {
                next_state.set(GameState::Paused);
            }
        }
        GameState::Paused => {
            if keyboard_input.just_pressed(KeyCode::Escape) {
                next_state.set(GameState::Playing);
            }
        }
        _ => {}
    }
}
```

## 13. 第二阶段：核心玩法

### 13.1 完整的塔防系统实现

```rust
// components.rs
use bevy::prelude::*;

#[derive(Component)]
pub struct Tower {
    pub tower_type: TowerType,
    pub level: u32,
    pub damage: f32,
    pub range: f32,
    pub fire_rate: f32,
    pub last_shot: f32,
}

#[derive(Component)]
pub struct Enemy {
    pub health: f32,
    pub max_health: f32,
    pub speed: f32,
    pub reward: u32,
    pub path_index: usize,
    pub path_progress: f32,
}

#[derive(Component)]
pub struct Projectile {
    pub damage: f32,
    pub speed: f32,
    pub target: Entity,
}

#[derive(Clone)]
pub enum TowerType {
    Bottle,
    Fan,
    Sun,
}

// systems/tower_system.rs
use bevy::prelude::*;
use crate::components::*;

pub fn tower_targeting_system(
    mut towers: Query<(&mut Tower, &Transform, &mut Target)>,
    enemies: Query<(Entity, &Transform, &Enemy)>,
    time: Res<Time>,
) {
    for (mut tower, tower_transform, mut target) in towers.iter_mut() {
        // 清除无效目标
        if let Some(current_target) = target.entity {
            if enemies.get(current_target).is_err() {
                target.entity = None;
            }
        }
        
        // 寻找新目标
        if target.entity.is_none() {
            let mut closest_distance = tower.range;
            let mut new_target = None;
            
            for (enemy_entity, enemy_transform, enemy) in enemies.iter() {
                let distance = tower_transform.translation
                    .truncate()
                    .distance(enemy_transform.translation.truncate());
                
                if distance <= tower.range && distance < closest_distance {
                    closest_distance = distance;
                    new_target = Some(enemy_entity);
                }
            }
            
            target.entity = new_target;
        }
    }
}

pub fn tower_shooting_system(
    mut commands: Commands,
    mut towers: Query<(&mut Tower, &Transform, &Target)>,
    time: Res<Time>,
    asset_server: Res<AssetServer>,
) {
    let current_time = time.elapsed_secs();
    
    for (mut tower, tower_transform, target) in towers.iter_mut() {
        if let Some(target_entity) = target.entity {
            if current_time - tower.last_shot >= 1.0 / tower.fire_rate {
                tower.last_shot = current_time;
                
                // 创建子弹
                commands.spawn((
                    Projectile {
                        damage: tower.damage,
                        speed: 300.0,
                        target: target_entity,
                    },
                    Sprite {
                        color: Color::srgb(1.0, 1.0, 0.0),
                        custom_size: Some(Vec2::new(8.0, 8.0)),
                        ..default()
                    },
                    Transform::from_translation(
                        tower_transform.translation + Vec3::new(0.0, 0.0, 0.1)
                    ),
                ));
            }
        }
    }
}
```

### 13.2 UI系统实现

```rust
// ui/game_ui.rs
use bevy::prelude::*;

#[derive(Component)]
pub struct GoldText;

#[derive(Component)]
pub struct LivesText;

#[derive(Component)]
pub struct WaveText;

pub fn setup_game_ui(mut commands: Commands) {
    // 顶部HUD
    commands.spawn((
        Node {
            width: Val::Percent(100.0),
            height: Val::Px(60.0),
            justify_content: JustifyContent::SpaceBetween,
            align_items: AlignItems::Center,
            padding: UiRect::all(Val::Px(20.0)),
            ..default()
        },
        BackgroundColor(Color::srgba(0.0, 0.0, 0.0, 0.8)),
    ))
    .with_children(|parent| {
        // 金币显示
        parent.spawn((
            Text::new("Gold: 500"),
            TextFont {
                font_size: 24.0,
                ..default()
            },
            TextColor(Color::srgb(1.0, 0.84, 0.0)),
            GoldText,
        ));
        
        // 波次显示
        parent.spawn((
            Text::new("Wave: 1/10"),
            TextFont {
                font_size: 24.0,
                ..default()
            },
            TextColor(Color::WHITE),
            WaveText,
        ));
        
        // 生命值显示
        parent.spawn((
            Text::new("Lives: 20"),
            TextFont {
                font_size: 24.0,
                ..default()
            },
            TextColor(Color::srgb(1.0, 0.2, 0.2)),
            LivesText,
        ));
    });
    
    // 底部塔选择栏
    commands.spawn((
        Node {
            position_type: PositionType::Absolute,
            bottom: Val::Px(20.0),
            left: Val::Percent(50.0),
            width: Val::Px(300.0),
            height: Val::Px(80.0),
            justify_content: JustifyContent::SpaceAround,
            align_items: AlignItems::Center,
            ..default()
        },
        BackgroundColor(Color::srgba(0.0, 0.0, 0.0, 0.8)),
        BorderRadius::all(Val::Px(10.0)),
    ))
    .with_children(|parent| {
        // 瓶子塔按钮
        spawn_tower_button(parent, TowerType::Bottle, 100);
        // 风扇塔按钮
        spawn_tower_button(parent, TowerType::Fan, 120);
        // 太阳塔按钮
        spawn_tower_button(parent, TowerType::Sun, 160);
    });
}

fn spawn_tower_button(
    parent: &mut ChildBuilder,
    tower_type: TowerType,
    cost: u32,
) {
    parent.spawn((
        Button,
        Node {
            width: Val::Px(60.0),
            height: Val::Px(60.0),
            justify_content: JustifyContent::Center,
            align_items: AlignItems::Center,
            ..default()
        },
        BackgroundColor(Color::srgb(0.2, 0.2, 0.2)),
        TowerButton { tower_type, cost },
    ))
    .with_children(|button| {
        button.spawn((
            Text::new(format!("${}", cost)),
            TextFont {
                font_size: 14.0,
                ..default()
            },
            TextColor(Color::WHITE),
        ));
    });
}

pub fn ui_update_system(
    gold: Res<Gold>,
    lives: Res<Lives>,
    wave_manager: Res<WaveManager>,
    mut gold_text: Query<&mut Text, (With<GoldText>, Without<LivesText>, Without<WaveText>)>,
    mut lives_text: Query<&mut Text, (With<LivesText>, Without<GoldText>, Without<WaveText>)>,
    mut wave_text: Query<&mut Text, (With<WaveText>, Without<GoldText>, Without<LivesText>)>,
) {
    if let Ok(mut text) = gold_text.get_single_mut() {
        text.0 = format!("Gold: {}", gold.0);
    }
    
    if let Ok(mut text) = lives_text.get_single_mut() {
        text.0 = format!("Lives: {}", lives.0);
    }
    
    if let Ok(mut text) = wave_text.get_single_mut() {
        text.0 = format!("Wave: {}/{}", wave_manager.current_wave, wave_manager.total_waves);
    }
}
```

## 14. 第三阶段：内容扩展

### 14.1 关卡编辑器

```rust
// level_editor.rs
use bevy::prelude::*;
use serde::{Serialize, Deserialize};

#[derive(Serialize, Deserialize)]
pub struct LevelData {
    pub name: String,
    pub grid_size: (usize, usize),
    pub path_points: Vec<(f32, f32)>,
    pub obstacles: Vec<ObstacleData>,
    pub waves: Vec<WaveData>,
    pub starting_gold: u32,
    pub starting_lives: u32,
}

#[derive(Serialize, Deserialize)]
pub struct ObstacleData {
    pub position: (i32, i32),
    pub health: u32,
    pub reward: u32,
}

#[derive(Serialize, Deserialize)]
pub struct WaveData {
    pub enemies: Vec<(String, u32)>,  // (enemy_type, count)
    pub spawn_interval: f32,
    pub wave_delay: f32,
}

// 关卡编辑器界面
pub fn level_editor_ui(
    mut commands: Commands,
    mut current_level: ResMut<LevelData>,
    keyboard: Res<ButtonInput<KeyCode>>,
    mouse: Res<ButtonInput<MouseButton>>,
) {
    // 快捷键
    if keyboard.pressed(KeyCode::ControlLeft) {
        if keyboard.just_pressed(KeyCode::KeyS) {
            save_level(&current_level);
        }
        if keyboard.just_pressed(KeyCode::KeyL) {
            load_level(&mut current_level);
        }
    }
    
    // 鼠标编辑
    if mouse.just_pressed(MouseButton::Left) {
        // 放置路径点
    }
    if mouse.just_pressed(MouseButton::Right) {
        // 放置障碍物
    }
}

fn save_level(level: &LevelData) {
    let json = serde_json::to_string_pretty(level).unwrap();
    std::fs::write(format!("assets/levels/{}.json", level.name), json).unwrap();
}

fn load_level(level: &mut LevelData) {
    let json = std::fs::read_to_string("assets/levels/level_1.json").unwrap();
    *level = serde_json::from_str(&json).unwrap();
}
```

### 14.2 成就系统

```rust
// achievements.rs
use bevy::prelude::*;
use serde::{Serialize, Deserialize};

#[derive(Serialize, Deserialize)]
pub struct Achievement {
    pub id: String,
    pub name: String,
    pub description: String,
    pub icon: String,
    pub unlocked: bool,
    pub progress: f32,
    pub target: f32,
}

#[derive(Resource)]
pub struct AchievementManager {
    pub achievements: Vec<Achievement>,
}

impl AchievementManager {
    pub fn check_achievement(&mut self, id: &str, progress: f32) {
        if let Some(achievement) = self.achievements.iter_mut().find(|a| a.id == id) {
            if !achievement.unlocked {
                achievement.progress = progress;
                if achievement.progress >= achievement.target {
                    achievement.unlocked = true;
                    // 触发解锁动画
                }
            }
        }
    }
}

// 成就检查系统
pub fn achievement_system(
    mut achievement_manager: ResMut<AchievementManager>,
    enemies_killed: Res<EnemiesKilled>,
    gold_earned: Res<GoldEarned>,
    towers_built: Res<TowersBuilt>,
) {
    // 击杀成就
    achievement_manager.check_achievement("killer_100", enemies_killed.0 as f32);
    achievement_manager.check_achievement("killer_1000", enemies_killed.0 as f32);
    
    // 金币成就
    achievement_manager.check_achievement("rich_1000", gold_earned.0 as f32);
    
    // 建造成就
    achievement_manager.check_achievement("builder_50", towers_built.0 as f32);
}
```

## 15. 第四阶段：打磨优化

### 15.1 性能分析工具

```rust
// debug.rs
use bevy::diagnostic::{DiagnosticsStore, FrameTimeDiagnosticsPlugin};

pub struct DebugPlugin;

impl Plugin for DebugPlugin {
    fn build(&self, app: &mut App) {
        app
            .add_plugins(FrameTimeDiagnosticsPlugin)
            .add_systems(Update, fps_display_system);
    }
}

fn fps_display_system(
    diagnostics: Res<DiagnosticsStore>,
    mut query: Query<&mut Text, With<FpsText>>,
) {
    if let Some(fps) = diagnostics.get(&FrameTimeDiagnosticsPlugin::FPS) {
        if let Some(value) = fps.smoothed() {
            for mut text in query.iter_mut() {
                text.0 = format!("FPS: {:.1}", value);
            }
        }
    }
}

// 性能分析命令
#[cfg(debug_assertions)]
pub fn debug_commands(
    keyboard: Res<ButtonInput<KeyCode>>,
    mut debug_settings: ResMut<DebugSettings>,
) {
    if keyboard.just_pressed(KeyCode::F1) {
        debug_settings.show_fps = !debug_settings.show_fps;
    }
    if keyboard.just_pressed(KeyCode::F2) {
        debug_settings.show_paths = !debug_settings.show_paths;
    }
    if keyboard.just_pressed(KeyCode::F3) {
        debug_settings.show_ranges = !debug_settings.show_ranges;
    }
}
```

### 15.2 游戏平衡调试

```rust
// balance_debug.rs
pub struct BalanceDebugPlugin;

impl Plugin for BalanceDebugPlugin {
    fn build(&self, app: &mut App) {
        #[cfg(debug_assertions)]
        app
            .add_systems(Update, balance_console_system)
            .insert_resource(BalanceConsole::default());
    }
}

#[derive(Resource, Default)]
struct BalanceConsole {
    input_buffer: String,
    history: Vec<String>,
}

fn balance_console_system(
    mut console: ResMut<BalanceConsole>,
    keyboard: Res<ButtonInput<KeyCode>>,
    mut balance_config: ResMut<BalanceConfig>,
) {
    // 按~打开控制台
    if keyboard.just_pressed(KeyCode::Backquote) {
        // 显示控制台UI
    }
    
    // 处理命令
    // 例如: "tower damage 1.5" - 将塔伤害倍率设为1.5
    // "enemy health 0.8" - 将敌人血量倍率设为0.8
    // "gold rate 2.0" - 将金币获取倍率设为2.0
}
```

### 15.3 发布准备

```rust
// build.rs
fn main() {
    // Windows图标
    #[cfg(windows)]
    {
        winres::WindowsResource::new()
            .set_icon("assets/icon.ico")
            .compile()
            .unwrap();
    }
}
```

```toml
# Cargo.toml 发布配置
[profile.release]
opt-level = "z"     # 最小体积优化
lto = true          # 链接时优化
codegen-units = 1   # 单代码生成单元
strip = true        # 移除符号
panic = "abort"     # 更小的panic处理

[profile.wasm-release]
inherits = "release"
opt-level = "z"
lto = "fat"
```

```bash
# 构建脚本
#!/bin/bash

# 桌面版本
cargo build --release

# Web版本
cargo build --release --target wasm32-unknown-unknown
wasm-bindgen --out-dir ./out/ --target web ./target/wasm32-unknown-unknown/release/tower_defense.wasm

# 打包
mkdir -p dist/windows
cp target/release/tower_defense.exe dist/windows/
cp -r assets dist/windows/

# 创建installer...
```

---

## 附录A：时间管理技巧

### 每日时间分配建议

```markdown
## 工作日（2-3小时）
- 30分钟：复习昨日进度，制定今日计划
- 1.5-2小时：核心开发
- 30分钟：测试和记录

## 周末（4-6小时）
- 1小时：本周总结和下周计划
- 3-4小时：大块功能开发
- 1小时：美术/音效制作
```

### 避免过度设计

```markdown
## 陷阱警告
❌ 不要在第一周就设计20种塔
❌ 不要实现复杂的粒子系统
❌ 不要过早优化性能
❌ 不要追求完美的代码架构

✅ 先实现，后优化
✅ 先简单，后复杂
✅ 先核心，后装饰
✅ 先可玩，后平衡
```

## 附录B：常见问题解决

### 技术问题

```markdown
Q: Bevy编译太慢怎么办？
A: 1. 使用dynamic_linking feature
   2. 使用mold链接器(Linux)或lld(Windows)
   3. 开启增量编译

Q: 游戏卡顿怎么办？
A: 1. 使用tracy或perf分析性能
   2. 减少实体数量
   3. 使用对象池
   4. 优化查询

Q: 内存占用过高？
A: 1. 及时despawn不用的实体
   2. 使用TextureAtlas合并图片
   3. 限制音效同时播放数量
```

### 设计问题

```markdown
Q: 关卡太难/太简单？
A: 记录通关率数据，使用Excel分析，逐步调整

Q: 玩家不知道怎么玩？
A: 第一关做成纯教学关，强制引导

Q: 游戏缺乏深度？
A: 增加塔的组合效果，敌人相克关系
```

## 附录C：发布和推广

### 发布平台

```markdown
## itch.io（推荐首选）
- 免费发布
- 支持Web版本
- 有社区反馈

## Steam
- $100发布费
- 需要准备更多材料
- 潜在用户更多

## 自建网站
- GitHub Pages托管Web版本
- 完全免费
- 需要自己推广
```

### 推广策略

```markdown
1. 开发日志
   - 在itch.io写开发日志
   - Twitter/X发布进度gif
   - Reddit r/rust_gamedev分享

2. 视频内容
   - 录制开发过程
   - B站/YouTube发布

3. 开源
   - GitHub开源获得关注
   - 写技术博客分享经验
```

## 总结

### 核心要点回顾

1. **60天可以完成**，但需要合理规划和持续执行
2. **MVP优先**，先做能玩的，再做好玩的
3. **利用现有资源**，不要从零造轮子
4. **保持简单**，宁可功能少而精，不要多而糙
5. **持续迭代**，每天都要有可见进展

### 第一步行动

```markdown
今天就开始：
1. 创建项目：cargo new tower_defense
2. 复制本文档中的基础代码
3. 运行看到一个窗口
4. 在窗口上画一个方块
5. 让方块能移动

恭喜！你已经开始了！
```

### 最后的话

做游戏是一个马拉松，不是短跑。保持节奏，享受过程，即使最后没有100%完成预定目标，你也已经学到了宝贵的经验。

记住：**完成比完美更重要**。

祝你开发顺利！🎮

---

*本指南约15000字，预计阅读时间2小时。建议收藏后分章节阅读，边读边实践。*